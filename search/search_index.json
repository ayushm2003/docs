{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ceramic Docs \u00b6 Ceramic is the public dataweb. An open network for deploying and managing information. Ceramic public infrastructure serves as a secure, performant data storage backend. Version control, verifiability, Something about the linked document model, something about DIDs. Whether you're building a fully-featured application that needs to write documents to a mutable decentralized backend, hacking together a project that needs to query open information, or just want to experiment with next-generation Web3 and peer-to-peer technologies, our developer platform has the tools to support you. Quick start Installation Learn the basics \u00b6 Protocol Overview \u00b6 Document Model \u00b6 Network Design \u00b6 Decentralized ID \u00b6 Development Tools \u00b6 HTTP Client \u00b6 JS Client \u00b6 CLI Client \u00b6 API Reference \u00b6 Resources \u00b6 :octicons-octoface-16: Discord \u00b6 :octicons-octoface-16: Blog \u00b6 :octicons-octoface-16: Github \u00b6","title":"Ceramic Docs"},{"location":"#ceramic-docs","text":"Ceramic is the public dataweb. An open network for deploying and managing information. Ceramic public infrastructure serves as a secure, performant data storage backend. Version control, verifiability, Something about the linked document model, something about DIDs. Whether you're building a fully-featured application that needs to write documents to a mutable decentralized backend, hacking together a project that needs to query open information, or just want to experiment with next-generation Web3 and peer-to-peer technologies, our developer platform has the tools to support you. Quick start Installation","title":"Ceramic Docs"},{"location":"#learn-the-basics","text":"","title":"Learn the basics"},{"location":"#development-tools","text":"","title":"Development Tools"},{"location":"#resources","text":"","title":"Resources"},{"location":"learn/","text":"","title":"Learn"},{"location":"authentication/dids/3id/","text":"3ID DID \u00b6 3ID is one of a few DID methods supported by Ceramic that can be used to perform authenticated writes to streams that require DIDs. This includes the two default StreamTypes: Tile Documents and CAIP-10 Links. When 3IDs are used in conjunction with IDX and the 3ID Keychain (as is implemented in 3ID Connect), a 3ID can easily be controlled with any number of blockchain accounts from any L1 or L2 network. This provides a way to unify a user's identity across all other platforms. Usage \u00b6 See the Authentication page to learn how to use the 3ID DID method in your Ceramic project. Design \u00b6 The DID document for a 3ID is stored natively on Ceramic as a Tile Document StreamType, allowing for mutability and enabling it to securely handle key rotations. This is a desireable property particularly for end user DIDs. Additionally since 3ID is native to Ceramic, developers do not need to operate additional infrastructure or rely on other external technologies. See CIP-79 for the full technical specification of the 3ID DID method. Other DID methods \u00b6 Ceramic supports a few different DID methods for authentication. Below find links to the others: Key DID NFT DID (coming soon) Safe DID (coming soon)","title":"3ID DID"},{"location":"authentication/dids/3id/#3id-did","text":"3ID is one of a few DID methods supported by Ceramic that can be used to perform authenticated writes to streams that require DIDs. This includes the two default StreamTypes: Tile Documents and CAIP-10 Links. When 3IDs are used in conjunction with IDX and the 3ID Keychain (as is implemented in 3ID Connect), a 3ID can easily be controlled with any number of blockchain accounts from any L1 or L2 network. This provides a way to unify a user's identity across all other platforms.","title":"3ID DID"},{"location":"authentication/dids/3id/#usage","text":"See the Authentication page to learn how to use the 3ID DID method in your Ceramic project.","title":"Usage"},{"location":"authentication/dids/3id/#design","text":"The DID document for a 3ID is stored natively on Ceramic as a Tile Document StreamType, allowing for mutability and enabling it to securely handle key rotations. This is a desireable property particularly for end user DIDs. Additionally since 3ID is native to Ceramic, developers do not need to operate additional infrastructure or rely on other external technologies. See CIP-79 for the full technical specification of the 3ID DID method.","title":"Design"},{"location":"authentication/dids/3id/#other-did-methods","text":"Ceramic supports a few different DID methods for authentication. Below find links to the others: Key DID NFT DID (coming soon) Safe DID (coming soon)","title":"Other DID methods"},{"location":"authentication/dids/key/","text":"Key DID \u00b6 Key DID is one of a few DID methods supported by Ceramic that can be used to perform authenticated writes to streams that require DIDs. This includes the two default StreamTypes: Tile Documents and CAIP-10 Links. Usage \u00b6 See the Authentication page to learn how to use the Key DID method in your Ceramic project. Design \u00b6 The DID document for a Key DID is statically generated from any Ed25519 cryptographic key pair. This Ed25519 key is used to control the DID. Key DID is lightweight, but the main drawback is that its DID document is immutable and has no ability to rotate keys if it is compromised; it is explicitly tied to a single crypto key. This makes Key DIDs best suited for users who will only want to ever use one keypair to control their DID, and who have strong key security practices - such as a developer. Other DID methods \u00b6 Ceramic supports a few different DID methods for authentication. Below find links to the others: 3ID DID NFT DID (coming soon) Safe DID (coming soon)","title":"Key DID"},{"location":"authentication/dids/key/#key-did","text":"Key DID is one of a few DID methods supported by Ceramic that can be used to perform authenticated writes to streams that require DIDs. This includes the two default StreamTypes: Tile Documents and CAIP-10 Links.","title":"Key DID"},{"location":"authentication/dids/key/#usage","text":"See the Authentication page to learn how to use the Key DID method in your Ceramic project.","title":"Usage"},{"location":"authentication/dids/key/#design","text":"The DID document for a Key DID is statically generated from any Ed25519 cryptographic key pair. This Ed25519 key is used to control the DID. Key DID is lightweight, but the main drawback is that its DID document is immutable and has no ability to rotate keys if it is compromised; it is explicitly tied to a single crypto key. This makes Key DIDs best suited for users who will only want to ever use one keypair to control their DID, and who have strong key security practices - such as a developer.","title":"Design"},{"location":"authentication/dids/key/#other-did-methods","text":"Ceramic supports a few different DID methods for authentication. Below find links to the others: 3ID DID NFT DID (coming soon) Safe DID (coming soon)","title":"Other DID methods"},{"location":"authentication/legacy/3id-connect-migration/","text":"3ID Migration: 3Box to Ceramic \u00b6 If you have used 3Box with 3ID-Connect in the past, you will already have an existing 3ID. No additional steps have to be taken to migrate your existing 3ID to the Ceramic network. When you interact with any application on Ceramic through 3ID-Connect, your 3ID will automatically be migrated. The migration includes moving your 3ID and control of your 3ID to the Ceramic network, migrating your 3Box profile to the profile definition and schema in IDX, and lastly migrating your address, Twitter and Github links. Any additional data in 3Box may or may not be migrated by the applications themselves built on 3Box. Those applications will guide you through any additional migration steps if necessary. Migration Difficulties \u00b6 Most users will be able to migrate without difficulty, but there is a number of known instances where we can not easily migrate your 3ID. In theses cases we will create a new 3ID for you and partially migrate any data that we can. You will be able to re-add any profile data and social links that fail to migrate in the future. Very Early 3Box Users Early 3Box users will have muport DIDs instead of the now standard 3ID DID implementation. For future interoperability in Ceramic and to take advantage of all the features in 3ID we have chosen not to migrate these DIDs. When you use 3ID-Connect on Ceramic we will detect that you have a muport DID and instead create a new 3ID for you. We will still migrate your profile data if we can, but will not migrate your Twitter and Github links. Multiple Linked Accounts There was a known past bug in 3Box that resulted in multiple addresses being linked to a DID in an unexpected way. When you use 3ID-Connect on Ceramic we will detect that you have one of these accounts and instead create a new 3ID for you. Users accounts that have this issue may not have expected to link these accounts, so we will not migrate your profile data or your social links. Migration Failures 3Box existed for a while before Ceramic and we may have not built support for all prior existing formats. If migration fails at any point during the process, we will still attempt partial migrations when we can and continue with a best effort migration. If migration fails during 3ID migration, we will create a new 3ID and try to migrate your profile data still. If migration fails during profile or social link migration, we will return your migrated 3ID anyways. For Developers \u00b6 You can find more details in this blog post , if you are interested in the more technical details of the migration or in migrating your own application from 3Box to Ceramic. Questions or support? \u00b6 We're always available to answer any questions and help you through this migration. Reach out to us in the Ceramic Discord for assistance.","title":"3Box Migration"},{"location":"authentication/legacy/3id-connect-migration/#3id-migration-3box-to-ceramic","text":"If you have used 3Box with 3ID-Connect in the past, you will already have an existing 3ID. No additional steps have to be taken to migrate your existing 3ID to the Ceramic network. When you interact with any application on Ceramic through 3ID-Connect, your 3ID will automatically be migrated. The migration includes moving your 3ID and control of your 3ID to the Ceramic network, migrating your 3Box profile to the profile definition and schema in IDX, and lastly migrating your address, Twitter and Github links. Any additional data in 3Box may or may not be migrated by the applications themselves built on 3Box. Those applications will guide you through any additional migration steps if necessary.","title":"3ID Migration: 3Box to Ceramic"},{"location":"authentication/legacy/3id-connect-migration/#migration-difficulties","text":"Most users will be able to migrate without difficulty, but there is a number of known instances where we can not easily migrate your 3ID. In theses cases we will create a new 3ID for you and partially migrate any data that we can. You will be able to re-add any profile data and social links that fail to migrate in the future. Very Early 3Box Users Early 3Box users will have muport DIDs instead of the now standard 3ID DID implementation. For future interoperability in Ceramic and to take advantage of all the features in 3ID we have chosen not to migrate these DIDs. When you use 3ID-Connect on Ceramic we will detect that you have a muport DID and instead create a new 3ID for you. We will still migrate your profile data if we can, but will not migrate your Twitter and Github links. Multiple Linked Accounts There was a known past bug in 3Box that resulted in multiple addresses being linked to a DID in an unexpected way. When you use 3ID-Connect on Ceramic we will detect that you have one of these accounts and instead create a new 3ID for you. Users accounts that have this issue may not have expected to link these accounts, so we will not migrate your profile data or your social links. Migration Failures 3Box existed for a while before Ceramic and we may have not built support for all prior existing formats. If migration fails at any point during the process, we will still attempt partial migrations when we can and continue with a best effort migration. If migration fails during 3ID migration, we will create a new 3ID and try to migrate your profile data still. If migration fails during profile or social link migration, we will return your migrated 3ID anyways.","title":"Migration Difficulties"},{"location":"authentication/legacy/3id-connect-migration/#for-developers","text":"You can find more details in this blog post , if you are interested in the more technical details of the migration or in migrating your own application from 3Box to Ceramic.","title":"For Developers"},{"location":"authentication/legacy/3id-connect-migration/#questions-or-support","text":"We're always available to answer any questions and help you through this migration. Reach out to us in the Ceramic Discord for assistance.","title":"Questions or support?"},{"location":"authentication/wallets/3id-connect/","text":"3ID Connect \u00b6 3ID Connect is the most widely used authentication provider for Ceramic. The 3ID Connect authentication SDK allows users to use a 3ID DID with their existing blockchain wallet(s). 3ID Connect was designed for developers building Ceramic-enabled web apps whose users already have a blockchain/crypto wallet. By using 3ID Connect, your users get to rely on the signing and key management capabilities of the crypto wallet(s) they already have instead of needing to install a separate wallet. 3ID Connect is not a substitute for a crypto wallet. It works alongside these wallets. Want to install 3ID Connect? Visit the installation section below. Want to try 3ID Connect? Visit Self.ID to try it in a live application. Supported blockchains \u00b6 Ethereum EVM compatible L1s and L2s (i.e. Avalanche, Moonbeam) NEAR (coming soon) EOS (coming soon) Cosmos (coming soon) Polkadot (coming soon) Want to add a new blockchain? Follow this tutorial to make a PR. Benefits \u00b6 For users \u00b6 Nothing to install : Users don't need to install 3ID Connect. They only need a blockchain wallet. Same identity across accounts : Users can use the same DID across many different blockchain accounts. Same identity across chains : Users can use the same DID across all L1 and L2 blockchain platforms. No additional key management : Users don't need to manage the private key for their DID \u2013 just their existing blockchain wallet. Automatic 3Box profile migration : Users' 3Box profiles will automatically be migrated by 3ID Connect the first time they use 3ID Connect via an application deployed on Ceramic Mainnet. Learn more about the 3Box profiles migration here . For developers \u00b6 Easy to install : See usage section below to add 3ID Connect to your project. 3ID provider : Access all methods in the 3ID DID provider. Better user experience : User-friendly design makes it seamless for your users to use DIDs. Works with web apps : Written in JavaScript/TypeScript and hosted in an iFrame. Installation \u00b6 Before installing 3ID Connect, you must have installed a Ceramic client and configured a DID for that client. By following the steps below, your users will be able to perform writes on Ceramic using a 3ID DID from their blockchain wallet. 1. Install from npm \u00b6 npm install @3id/connect 2. Import the provider \u00b6 import { ThreeIdConnect, <BlockchainAuthProvider> } from '@3id/connect' Understanding BlockchainAuthProvider The BlockchainAuthProvider parameter is always required but the name shown here is just a placeholder. In your application, you should substitute in the specific BlockchainAuthProvider you are using. A full list of supported BlockchainAuthProviders can be found here . Example using an Ethereum wallet: import { ThreeIdConnect, EthereumAuthProvider } from '@3id/connect' 3. Request user's address \u00b6 const addresses = await <blockchainName>.enable() Example using an Ethereum wallet: const addresses = await window.ethereum.enable() 4. Request authentication \u00b6 const threeIdConnect = new ThreeIdConnect() const authProvider = new <BlockchainAuthProvider>(<blockchainName>, addresses[0]) await threeIdConnect.connect(authProvider) Example using an Ethereum wallet: const authProvider = new EthereumAuthProvider(window.ethereum, addresses[0]) await threeIdConnect.connect(authProvider) This will prompt the user with a 3ID Connect permissions window. 5. Create provider instance \u00b6 const provider = await threeIdConnect.getDidProvider() 6. Set the provider \u00b6 Set the Provider instance to the DID instance used by your Ceramic client in order to perform writes. ceramic.did.setProvider(provider) 7. Authenticate the DID \u00b6 await ceramic.did.authenticate() This will prompt the user with a 3ID Connect permissions window. Your users will now be authenticated and can perform writes to streams on Ceramic. Underlying technologies \u00b6 3ID Connect is built on open source technologies and standards. Learn more about the technologies that make 3ID Connect possible. 3ID DIDs (CIP-79) : For creating decentralized identifiers and authenticating to Ceramic IDX (CIP-11) : Protocol and SDK for storing data streams controlled by the user's 3ID 3ID Keychain (CIP-20) : IDX definition and schema for using a TileDocument StreamType to store a list of encrypted authentication secrets for each wallet account CAIP10Link (CIP-7) : StreamType for publicly linking a wallet account to a 3ID DID Crypto accounts (CIP-21) : IDX definition and schema for using a TileDocument StreamType to store a list of streamIDs for a DID's CAIP10Links Maintainers \u00b6 3ID Connect is maintained by 3Box Labs . License \u00b6 3ID Connect is 100% open source under MIT and Apache 2.","title":"3ID Connect"},{"location":"authentication/wallets/3id-connect/#3id-connect","text":"3ID Connect is the most widely used authentication provider for Ceramic. The 3ID Connect authentication SDK allows users to use a 3ID DID with their existing blockchain wallet(s). 3ID Connect was designed for developers building Ceramic-enabled web apps whose users already have a blockchain/crypto wallet. By using 3ID Connect, your users get to rely on the signing and key management capabilities of the crypto wallet(s) they already have instead of needing to install a separate wallet. 3ID Connect is not a substitute for a crypto wallet. It works alongside these wallets. Want to install 3ID Connect? Visit the installation section below. Want to try 3ID Connect? Visit Self.ID to try it in a live application.","title":"3ID Connect"},{"location":"authentication/wallets/3id-connect/#benefits","text":"","title":"Benefits"},{"location":"authentication/wallets/3id-connect/#for-users","text":"Nothing to install : Users don't need to install 3ID Connect. They only need a blockchain wallet. Same identity across accounts : Users can use the same DID across many different blockchain accounts. Same identity across chains : Users can use the same DID across all L1 and L2 blockchain platforms. No additional key management : Users don't need to manage the private key for their DID \u2013 just their existing blockchain wallet. Automatic 3Box profile migration : Users' 3Box profiles will automatically be migrated by 3ID Connect the first time they use 3ID Connect via an application deployed on Ceramic Mainnet. Learn more about the 3Box profiles migration here .","title":"For users"},{"location":"authentication/wallets/3id-connect/#for-developers","text":"Easy to install : See usage section below to add 3ID Connect to your project. 3ID provider : Access all methods in the 3ID DID provider. Better user experience : User-friendly design makes it seamless for your users to use DIDs. Works with web apps : Written in JavaScript/TypeScript and hosted in an iFrame.","title":"For developers"},{"location":"authentication/wallets/3id-connect/#installation","text":"Before installing 3ID Connect, you must have installed a Ceramic client and configured a DID for that client. By following the steps below, your users will be able to perform writes on Ceramic using a 3ID DID from their blockchain wallet.","title":"Installation"},{"location":"authentication/wallets/3id-connect/#1-install-from-npm","text":"npm install @3id/connect","title":"1. Install from npm"},{"location":"authentication/wallets/3id-connect/#2-import-the-provider","text":"import { ThreeIdConnect, <BlockchainAuthProvider> } from '@3id/connect' Understanding BlockchainAuthProvider The BlockchainAuthProvider parameter is always required but the name shown here is just a placeholder. In your application, you should substitute in the specific BlockchainAuthProvider you are using. A full list of supported BlockchainAuthProviders can be found here . Example using an Ethereum wallet: import { ThreeIdConnect, EthereumAuthProvider } from '@3id/connect'","title":"2. Import the provider"},{"location":"authentication/wallets/3id-connect/#3-request-users-address","text":"const addresses = await <blockchainName>.enable() Example using an Ethereum wallet: const addresses = await window.ethereum.enable()","title":"3. Request user's address"},{"location":"authentication/wallets/3id-connect/#4-request-authentication","text":"const threeIdConnect = new ThreeIdConnect() const authProvider = new <BlockchainAuthProvider>(<blockchainName>, addresses[0]) await threeIdConnect.connect(authProvider) Example using an Ethereum wallet: const authProvider = new EthereumAuthProvider(window.ethereum, addresses[0]) await threeIdConnect.connect(authProvider) This will prompt the user with a 3ID Connect permissions window.","title":"4. Request authentication"},{"location":"authentication/wallets/3id-connect/#5-create-provider-instance","text":"const provider = await threeIdConnect.getDidProvider()","title":"5. Create provider instance"},{"location":"authentication/wallets/3id-connect/#6-set-the-provider","text":"Set the Provider instance to the DID instance used by your Ceramic client in order to perform writes. ceramic.did.setProvider(provider)","title":"6. Set the provider"},{"location":"authentication/wallets/3id-connect/#7-authenticate-the-did","text":"await ceramic.did.authenticate() This will prompt the user with a 3ID Connect permissions window. Your users will now be authenticated and can perform writes to streams on Ceramic.","title":"7. Authenticate the DID"},{"location":"authentication/wallets/3id-connect/#underlying-technologies","text":"3ID Connect is built on open source technologies and standards. Learn more about the technologies that make 3ID Connect possible. 3ID DIDs (CIP-79) : For creating decentralized identifiers and authenticating to Ceramic IDX (CIP-11) : Protocol and SDK for storing data streams controlled by the user's 3ID 3ID Keychain (CIP-20) : IDX definition and schema for using a TileDocument StreamType to store a list of encrypted authentication secrets for each wallet account CAIP10Link (CIP-7) : StreamType for publicly linking a wallet account to a 3ID DID Crypto accounts (CIP-21) : IDX definition and schema for using a TileDocument StreamType to store a list of streamIDs for a DID's CAIP10Links","title":"Underlying technologies"},{"location":"authentication/wallets/3id-connect/#maintainers","text":"3ID Connect is maintained by 3Box Labs .","title":"Maintainers"},{"location":"authentication/wallets/3id-connect/#license","text":"3ID Connect is 100% open source under MIT and Apache 2.","title":"License"},{"location":"build/authentication/","text":"Authentication \u00b6 This guide will help you add authentication to your project. Authentication is needed to perform writes . If you only need to perform queries , you do not need authentication. Prerequisites \u00b6 Authentication requires having installed a Ceramic client in your project. Choose your setup \u00b6 DID method \u00b6 The first step in adding authentication to your project is choosing which DID method you want to support for user accounts. Due to their mutability and security, it is recommended that you use 3ID DID for users. DID Method Description Registration DID Documents Details 3ID DID A complete and flexible DID method built on Ceramic that supports key rotations and revocations Ceramic Mutable Learn Key DID A lightweight but inflexible DID method that does not support key rotations None Immutable Learn DID provider or wallet \u00b6 After deciding on a DID method, you need to install either a wallet or a provider for that method. The most commonly used DID providers and wallets can be found below. For most browser applications, it is recommended that you use 3ID Connect. Name DID Method Type Description Details 3ID Connect 3ID DID Wallet A hosted wallet and authentication system for browser apps using 3ID DIDs. Your application is not responsible for key management, and users can authenticate with their existing blockchain wallets. Learn 3id-did-provider 3ID DID Provider A JavaScript library for creating and interacting with 3ID DIDs. Your application is responsible for key management, and users need to authenticate with a DID seed or an auth secret. Learn key-did-provider-ed25519 Key DID Provider A JavaScript library for creating and interacting with Key DIDs. Your application is responsible for key managemet, and users need to authenticate with a DID seed. Learn Installation \u00b6 Install a DID wallet or provider in your project using npm. 3ID Connect $ npm install @3id/connect 3id-did-provider $ npm install 3id-did-provider key-did-provider $ npm install key-did-provider-ed25519 Create the Provider \u00b6 The authentication process varies depending on which wallet or provider you are using. Closely follow the steps below. 3ID Connect Visit the 3ID Connect page for instructions. 3id-did-provider Import the provider \u00b6 import ThreeIdProvider from '3id-did-provider' Get seed for DID \u00b6 Generate a random seed for a new user, or somehow get the existing seed for a returning user. Seeds should be a 32 byte Uint8Array. How to generate a seed Here's how to securely generate a seed in the proper format: import { randomBytes } from '@stablelib/random' const seed = randomBytes ( 32 ) Create a provider instance \u00b6 Option 1: Using the seed \u00b6 const threeId = await ThreeIdProvider . create ({ getPermission , seed }) const provider = threeId . getDidProvider () Option 2: Using an external auth method \u00b6 This option is useful if you want to enable multiple secrets (seeds) that are capable of controlling the 3ID DID. How to generate an authSecret Here's how to securely generate a seed in the proper format: import { randomBytes } from '@stablelib/random' const authSecret = randomBytes ( 32 ) const authId = 'myAuthenticationMethod' // a name of the auth method const threeId = await ThreeIdProvider . create ({ getPermission , authSecret , authId }) const provider = threeId . getDidProvider () Understanding getPermission The getPermission parameter is always required when creating an instance of ThreeIdProvider. It is used to give an application permission to decrypt and sign data. This function should present a dialog to the user in the wallet UI which asks for permission to access the given paths. The function is called with one parameter which is the request object. It looks like this: { type : 'authenticate' , origin : 'https://my.app.origin' , payload : { paths : [ '/path/1' , '/path/2' ] } } In the above example the app with origin https://my.app.origin is requesting access to /path/1 and /path/2. If the user approves, the function should return the paths array. If they decline, it will return an empty array. Note that a user may approve only some of the requested paths, which would return an array containing only the approved paths. The most simple getPermission function simply grants all requested permissions. const getPermission = async ( request ) => { return request . payload . paths } key-did-provider Import the provider \u00b6 Import the Key DID provider into your project. import { Ed25519Provider } from 'key-did-provider-ed25519' Get seed for DID \u00b6 Generate a random seed for a new user, or somehow get the existing seed for a returning user. Seeds should be a 32 byte Uint8Array. How to generate a seed Here's how to securely generate a seed in the proper format: import { randomBytes } from '@stablelib/random' const seed = randomBytes ( 32 ) Create a provider instance using the seed \u00b6 const provider = new Ed25519Provider ( seed ) Set the Provider \u00b6 Set the Provider instance to the DID instance used by your Ceramic client in order to perform writes. ceramic . did . setProvider ( provider ) Authenticate the DID \u00b6 Now all that's left is to authenticate to the Ceramic client's DID instance using the configured DID Provider. If you're using ThreeIdConnect, this step will cause a pop-up in your browser requesting permission to authenticate the DID. await ceramic . did . authenticate () Usage \u00b6 After authenticating, the user will now be able to perform writes on Ceramic using their DID.","title":"Authentication"},{"location":"build/authentication/#authentication","text":"This guide will help you add authentication to your project. Authentication is needed to perform writes . If you only need to perform queries , you do not need authentication.","title":"Authentication"},{"location":"build/authentication/#prerequisites","text":"Authentication requires having installed a Ceramic client in your project.","title":"Prerequisites"},{"location":"build/authentication/#choose-your-setup","text":"","title":"Choose your setup"},{"location":"build/authentication/#did-method","text":"The first step in adding authentication to your project is choosing which DID method you want to support for user accounts. Due to their mutability and security, it is recommended that you use 3ID DID for users. DID Method Description Registration DID Documents Details 3ID DID A complete and flexible DID method built on Ceramic that supports key rotations and revocations Ceramic Mutable Learn Key DID A lightweight but inflexible DID method that does not support key rotations None Immutable Learn","title":"DID method"},{"location":"build/authentication/#did-provider-or-wallet","text":"After deciding on a DID method, you need to install either a wallet or a provider for that method. The most commonly used DID providers and wallets can be found below. For most browser applications, it is recommended that you use 3ID Connect. Name DID Method Type Description Details 3ID Connect 3ID DID Wallet A hosted wallet and authentication system for browser apps using 3ID DIDs. Your application is not responsible for key management, and users can authenticate with their existing blockchain wallets. Learn 3id-did-provider 3ID DID Provider A JavaScript library for creating and interacting with 3ID DIDs. Your application is responsible for key management, and users need to authenticate with a DID seed or an auth secret. Learn key-did-provider-ed25519 Key DID Provider A JavaScript library for creating and interacting with Key DIDs. Your application is responsible for key managemet, and users need to authenticate with a DID seed. Learn","title":"DID provider or wallet"},{"location":"build/authentication/#installation","text":"Install a DID wallet or provider in your project using npm. 3ID Connect $ npm install @3id/connect 3id-did-provider $ npm install 3id-did-provider key-did-provider $ npm install key-did-provider-ed25519","title":"Installation"},{"location":"build/authentication/#create-the-provider","text":"The authentication process varies depending on which wallet or provider you are using. Closely follow the steps below. 3ID Connect Visit the 3ID Connect page for instructions. 3id-did-provider","title":"Create the Provider"},{"location":"build/authentication/#set-the-provider","text":"Set the Provider instance to the DID instance used by your Ceramic client in order to perform writes. ceramic . did . setProvider ( provider )","title":"Set the Provider"},{"location":"build/authentication/#authenticate-the-did","text":"Now all that's left is to authenticate to the Ceramic client's DID instance using the configured DID Provider. If you're using ThreeIdConnect, this step will cause a pop-up in your browser requesting permission to authenticate the DID. await ceramic . did . authenticate ()","title":"Authenticate the DID"},{"location":"build/authentication/#usage","text":"After authenticating, the user will now be able to perform writes on Ceramic using their DID.","title":"Usage"},{"location":"build/installation/","text":"Installation \u00b6 Install a client to perform writes and queries . There are multiple ways to setup, run, and use Ceramic. This page describes the options. MAINNET NOW LIVE! We're onboarding the first projects to Mainnet from the waitlist. If you want to deploy to mainnet in the near future, sign up for the Mainnet waitlist . While on the waitlist, you can always develop and prototype your integration on the Clay Testnet . Demonstrating a fully-functioning integration that is ready for mainnet is a great way to increase your odds of being seleted from the waitlist. If you have questions or need further prioritization, you can join the Discord and let us know. Install a client \u00b6 Ceramic is available in a variety of clients suited for different use cases. Language Client Description Usage Details JavaScript HTTP Allows your project to interact with a remote Ceramic node over HTTP Most apps ( recommended ) Learn and install JavaScript Core Allows your project to run the full Ceramic protocol (API and node) in any JS environment Tests, fully client side apps, node.js Learn and install JavaScript CLI Allows developers to spin up a Ceramic node and/or interact with Ceramic from the command line Command line, hosting a node Learn and install For optimal performance and data availability, it is recommended that you use the HTTP Client when building an application.","title":"Installation"},{"location":"build/installation/#installation","text":"Install a client to perform writes and queries . There are multiple ways to setup, run, and use Ceramic. This page describes the options. MAINNET NOW LIVE! We're onboarding the first projects to Mainnet from the waitlist. If you want to deploy to mainnet in the near future, sign up for the Mainnet waitlist . While on the waitlist, you can always develop and prototype your integration on the Clay Testnet . Demonstrating a fully-functioning integration that is ready for mainnet is a great way to increase your odds of being seleted from the waitlist. If you have questions or need further prioritization, you can join the Discord and let us know.","title":"Installation"},{"location":"build/installation/#install-a-client","text":"Ceramic is available in a variety of clients suited for different use cases. Language Client Description Usage Details JavaScript HTTP Allows your project to interact with a remote Ceramic node over HTTP Most apps ( recommended ) Learn and install JavaScript Core Allows your project to run the full Ceramic protocol (API and node) in any JS environment Tests, fully client side apps, node.js Learn and install JavaScript CLI Allows developers to spin up a Ceramic node and/or interact with Ceramic from the command line Command line, hosting a node Learn and install For optimal performance and data availability, it is recommended that you use the HTTP Client when building an application.","title":"Install a client"},{"location":"build/pinning/","text":"Pinning \u00b6 Pinning allows you to add and remove streams from the permanent pinset in your Ceramic node. By default Ceramic will garbage collect any stream that has been created, modified, or loaded after some period of time. In order to prevent the loss of streams due to garbage collection, you need to pin the streams that you wish to persist. Pinning instructs the Ceramic node to keep them around in persistent storage until they are unpinned. Prerequisites \u00b6 Pinning requires having installed a Ceramic client in your project. Add to pinset \u00b6 Use the pin.add() method to add a stream to your permanent pinset. const streamId = 'kjzl6cwe1jw14...' await ceramic . pin . add ( streamId ) API reference Remove from pinset \u00b6 Use the pin.rm() method to remove a stream from your permanent pinset. const streamId = 'kjzl6cwe1jw14...' await ceramic . pin . rm ( streamId ) API reference List streamss in pinset \u00b6 Use the pin.ls() method to list streams currently in your permanent pinset. const streamIds = await ceramic . pin . ls () API reference","title":"Pinning"},{"location":"build/pinning/#pinning","text":"Pinning allows you to add and remove streams from the permanent pinset in your Ceramic node. By default Ceramic will garbage collect any stream that has been created, modified, or loaded after some period of time. In order to prevent the loss of streams due to garbage collection, you need to pin the streams that you wish to persist. Pinning instructs the Ceramic node to keep them around in persistent storage until they are unpinned.","title":"Pinning"},{"location":"build/pinning/#prerequisites","text":"Pinning requires having installed a Ceramic client in your project.","title":"Prerequisites"},{"location":"build/pinning/#add-to-pinset","text":"Use the pin.add() method to add a stream to your permanent pinset. const streamId = 'kjzl6cwe1jw14...' await ceramic . pin . add ( streamId ) API reference","title":"Add to pinset"},{"location":"build/pinning/#remove-from-pinset","text":"Use the pin.rm() method to remove a stream from your permanent pinset. const streamId = 'kjzl6cwe1jw14...' await ceramic . pin . rm ( streamId ) API reference","title":"Remove from pinset"},{"location":"build/pinning/#list-streamss-in-pinset","text":"Use the pin.ls() method to list streams currently in your permanent pinset. const streamIds = await ceramic . pin . ls () API reference","title":"List streamss in pinset"},{"location":"build/queries/","text":"Queries \u00b6 This guide demonstrates how to query documents on the Ceramic network during runtime using the HTTP and core clients. You can also use the CLI to query documents as shown in the Quick Start guide. Prerequisites \u00b6 You need to have an installed client to perform queries during runtime. Query a stream \u00b6 Use the loadStream() method to load a single stream using its StreamID . const streamId = 'kjzl6cwe1jw14...' const stream = await ceramic . loadStream ( streamId ) Loading the proper stream type When using the Typescript APIs, loadStream by default returns an object of type Stream , which will not have any methods available to perform updates, or any other streamtype-specific methods or accessors. To be able to perform updates, as well as to access streamtype-specific data or functionality, you need to specialize the loadStream method on the StreamType of the Stream being loaded. For example, to load a TileDocument , you would say await ceramic.loadStream<TileDocument>(streamId) API reference Load a stream at a specific commit \u00b6 If you want to see the contents of a stream as of a specific point in time, it's possible to pass a CommitID instead of a StreamID to the loadStream() method. This will cause the Stream to be loaded at the specified commit, rather than the current commit as loaded from the network. When loading with a CommitID the returned Stream object will be marked as readonly and cannot be used to perform updates. If you wish to perform updates, load a new instance of the Stream using its StreamID. Query multiple streams \u00b6 Use the multiQuery() method to load multiple streams at once. The returned object is a map from StreamIDs to stream instances. const queries = [{ streamId : 'kjzl6cwe1jw...14' }, { streamId : 'kjzl6cwe1jw...15' }] const streamMap = await ceramic . multiQuery ( queries ) API reference Query document paths \u00b6 Use the multiQuery() method to load one or more streams using known paths from a root stream to its linked streams. Imagine a stream kjzl6cwe1jw...14 whose content contains the StreamIDs of two other streams. These StreamIDs exist at various levels within a nested JSON structure. { a : 'kjzl6cwe1jw...15' , b : { c : 'kjzl6cwe1jw...16' } } In the stream above, the path from root stream kjzl6cwe1jw...14 to linked stream kjzl6cwe1jw...15 is /a and the path to linked stream kjzl6cwe1jw...16 is /b/c . Using the StreamID of the root stream and the paths outlined here, we use multiQuery() to query all three streams at once without needing to explicitly know the StreamIDs of the two linked streams. The multiQuery() below will return a map with all three streams. const queries = [{ streamId : 'kjzl6cwe1jw...14' paths : [ '/a' , '/b/c' ] }] const streamMap = await ceramic . multiQuery ( queries ) API reference Stream information \u00b6 To get specific information about the stream that you created or loaded you can use the accessors on the Stream class. Below are some examples. API reference StreamID \u00b6 Use the stream.id property to get the unique StreamID for this stream. const streamId = stream . id API reference Latest CommitID \u00b6 Use the stream.commitId property to get latest CommitID of a stream. const commitId = stream . commitId API reference Anchor CommitIDs \u00b6 Use the stream.anchorCommitIds property to get all CommitIDs which are anchor commits for this stream. const anchorCommits = stream . anchorCommitIds API reference","title":"Queries"},{"location":"build/queries/#queries","text":"This guide demonstrates how to query documents on the Ceramic network during runtime using the HTTP and core clients. You can also use the CLI to query documents as shown in the Quick Start guide.","title":"Queries"},{"location":"build/queries/#prerequisites","text":"You need to have an installed client to perform queries during runtime.","title":"Prerequisites"},{"location":"build/queries/#query-a-stream","text":"Use the loadStream() method to load a single stream using its StreamID . const streamId = 'kjzl6cwe1jw14...' const stream = await ceramic . loadStream ( streamId ) Loading the proper stream type When using the Typescript APIs, loadStream by default returns an object of type Stream , which will not have any methods available to perform updates, or any other streamtype-specific methods or accessors. To be able to perform updates, as well as to access streamtype-specific data or functionality, you need to specialize the loadStream method on the StreamType of the Stream being loaded. For example, to load a TileDocument , you would say await ceramic.loadStream<TileDocument>(streamId) API reference","title":"Query a stream"},{"location":"build/queries/#load-a-stream-at-a-specific-commit","text":"If you want to see the contents of a stream as of a specific point in time, it's possible to pass a CommitID instead of a StreamID to the loadStream() method. This will cause the Stream to be loaded at the specified commit, rather than the current commit as loaded from the network. When loading with a CommitID the returned Stream object will be marked as readonly and cannot be used to perform updates. If you wish to perform updates, load a new instance of the Stream using its StreamID.","title":"Load a stream at a specific commit"},{"location":"build/queries/#query-multiple-streams","text":"Use the multiQuery() method to load multiple streams at once. The returned object is a map from StreamIDs to stream instances. const queries = [{ streamId : 'kjzl6cwe1jw...14' }, { streamId : 'kjzl6cwe1jw...15' }] const streamMap = await ceramic . multiQuery ( queries ) API reference","title":"Query multiple streams"},{"location":"build/queries/#query-document-paths","text":"Use the multiQuery() method to load one or more streams using known paths from a root stream to its linked streams. Imagine a stream kjzl6cwe1jw...14 whose content contains the StreamIDs of two other streams. These StreamIDs exist at various levels within a nested JSON structure. { a : 'kjzl6cwe1jw...15' , b : { c : 'kjzl6cwe1jw...16' } } In the stream above, the path from root stream kjzl6cwe1jw...14 to linked stream kjzl6cwe1jw...15 is /a and the path to linked stream kjzl6cwe1jw...16 is /b/c . Using the StreamID of the root stream and the paths outlined here, we use multiQuery() to query all three streams at once without needing to explicitly know the StreamIDs of the two linked streams. The multiQuery() below will return a map with all three streams. const queries = [{ streamId : 'kjzl6cwe1jw...14' paths : [ '/a' , '/b/c' ] }] const streamMap = await ceramic . multiQuery ( queries ) API reference","title":"Query document paths"},{"location":"build/queries/#stream-information","text":"To get specific information about the stream that you created or loaded you can use the accessors on the Stream class. Below are some examples. API reference","title":"Stream information"},{"location":"build/queries/#streamid","text":"Use the stream.id property to get the unique StreamID for this stream. const streamId = stream . id API reference","title":"StreamID"},{"location":"build/queries/#latest-commitid","text":"Use the stream.commitId property to get latest CommitID of a stream. const commitId = stream . commitId API reference","title":"Latest CommitID"},{"location":"build/queries/#anchor-commitids","text":"Use the stream.anchorCommitIds property to get all CommitIDs which are anchor commits for this stream. const anchorCommits = stream . anchorCommitIds API reference","title":"Anchor CommitIDs"},{"location":"build/quick-start/","text":"Quick start \u00b6 Learn the basics by setting up and interacting with the Ceramic CLI . This tutorial serves as a simple introduction to Ceramic concepts. See installation to install Ceramic in your project and start building applications. Want an even faster way to try Ceramic? Visit the Playground demo app to test the full stack of Ceramic components in the browser. 1. Install the CLI \u00b6 Visit the Ceramic CLI page for instructions on how to quickly install the CLI. 2. Create a stream \u00b6 Use the create command to create a new stream . In the example below we create a stream that uses the TileDocument StreamType . Note that TileDocument is the only StreamType that can currently be created by the Ceramic CLI. Command $ ceramic create tile --content '{ \"Foo\": \"Bar\" }' Output StreamID ( kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa ) { \"Foo\" : \"Bar\" } The first line of the output is the StreamID , which is the persistent identifier of our newly created stream. This StreamID will be different for you, since you created it with your DID. Below the StreamID is the current content of the stream. More options --controllers : set the controller of the stream --schema : set the schema of the TileDocument Run ceramic create -h to see all available options 3. Query a stream \u00b6 Use the show command to query the current state of a stream. You will need to provide its StreamID . Command $ ceramic show kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa You should use your StreamID instead of the StreamID included here. Output { \"Foo\" : \"Bar\" } Use the state command to query the entire state of a stream. Command $ ceramic state kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa You should use your StreamID instead of the StreamID included here. Output before anchor { \"type\" : 0 , \"content\" : { \"Foo\" : \"Bar\" } , \"metadata\" : { \"unique\" : \"E4qPslUd0qo98TZX\" , \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/24/2021, 11:45:00 AM\" } Here we can see various information about the stream such as content , controllers , and schema . In your output you should see your local DID as the controller, instead of the DID we show here. You will also see a different randomly-generated \"unique\" string for any TileDocument that was created without the --deterministic flag. We can also see the current anchorStatus of our stream, and that it has been scheduled to be anchored at 11:45 on the 24 th of January 2021. Once this anchor is finalized, the state of the stream will automatically be updated with a new entry in the log and anchorStatus will be set to ANCHORED . Output after anchor { \"type\" : 0 , \"content\" : { \"Foo\" : \"Bar\" } , \"metadata\" : { \"unique\" : \"E4qPslUd0qo98TZX\" , \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"ANCHORED\" , \"log\" : [ { \"cid\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"type\" : 0 } , { \"cid\" : \"bafyreig6hostufw42cmz2cnn7hpvb6pau67a2n2syhzej7orqxfymdayyq\" , \"type\" : 2 } ] , \"anchorScheduledFor\" : null, \"anchorProof\" : { \"root\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"txHash\" : \"bagjqcgza4xgkpjodtqtgyu2fx6rdr6fb6mhevd5hy4253tl6pjlssidpwaha\" , \"chainId\" : \"eip155:3\" , \"blockNumber\" : 9527752 , \"blockTimestamp\" : 1611485094 } } This output was seen after the anchor has been created. The stream state has now shifted anchorStatus to ANCHORED . You can also see that the log contains one more entry. 4. Update a stream \u00b6 Use the update command to update a stream. Your DID must be the controller of the stream in order to update it. Note that TileDocument is the only StreamType that can currently be updated by the CLI. Command $ ceramic update kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa --content '{ \"Foo\": \"Baz\" }' You should use your StreamID instead of the StreamID included here. Output { \"Foo\" : \"Baz\" } More options Currently you can change content , controllers , and schema using the CLI. Run ceramic update -h for more information. 5. Create a schema \u00b6 TileDocuments can enforce that their contents adhere to a specified schema. The schemas themselves are TileDocuments where the content is a json-schema . For example we can create a schema that requires a TileDocument to have a title and message . Command $ ceramic create tile --content ' { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Reward\", \"type\": \"object\", \"properties\": { \"title\": { \"type\": \"string\" }, \"message\": { \"type\": \"string\" } }, \"required\": [ \"message\", \"title\" ] }' Output StreamID ( kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb ) { \"type\" : \"object\" , \"title\" : \"Reward\" , \" $schema \" : \"http://json-schema.org/draft-07/schema#\" , \"required\" : [ \"message\" , \"title\" ] , \"properties\" : { \"title\" : { \"type\" : \"string\" } , \"message\" : { \"type\" : \"string\" } } } 6. Create a TileDocument stream that uses a schema \u00b6 First, use the commits command to list the commitIDs contained in the schema stream. When creating a TileDocument that uses this schema, we need to use a commitID instead of the StreamID to enforce that we are using a specific version of the schema since the schema stream is mutable and can be updated. Command $ ceramic commits kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb You should use your StreamID for the stream containing the json-schema you want to enforce, instead of the StreamID included here. Output [ \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" ] If a stream contains multiple commits and you're not sure which one you want, use the show command to show the content of the stream at the given commit. Once you retrieve the desired commit, you can now create a TileDocument that is enforced to conform to this version of the schema. Use the create command and pass the --schema option along with your commitID. Command $ ceramic create tile --content '{ \"title\": \"My first document with schema\", \"message\": \"Hello World\" }' --schema k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8 You should use your commitID instead of the commitID included here. Output StreamID ( kjzl6cwe1jw149tvfh6otqfzd2hfknkifb1z2lakozkicvau0xldzzdzwfbsztj ) { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" } 7. Query the stream you created \u00b6 Use the state command to query the state of the TileDocument we just created. We can see that the schema is set to the correct commitID. Command $ ceramic state kjzl6cwe1jw14b5sr79heovz7fziz4dxcn8upx3bcesriloqcui137k6rq6g2mn You should use your StreamID instead of the StreamID included here. Output { \"type\" : 0 , \"content\" : { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" } , \"metadata\" : { \"unique\" : \"GR5tBtHdaw608esV\" , \"schema\" : \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" , \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera5qxg5zabjjvwpcbia6c3t6vebgo4brgmsagxezdjgk4vxnzwb5hq\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/13/2021, 1:45:00 PM\" } That's it! \u00b6 Congratulations on completing this tutorial! You're well on your way to becoming a Ceramic developer. Now let's install Ceramic in your project \u2192","title":"Quick Start"},{"location":"build/quick-start/#quick-start","text":"Learn the basics by setting up and interacting with the Ceramic CLI . This tutorial serves as a simple introduction to Ceramic concepts. See installation to install Ceramic in your project and start building applications. Want an even faster way to try Ceramic? Visit the Playground demo app to test the full stack of Ceramic components in the browser.","title":"Quick start"},{"location":"build/quick-start/#1-install-the-cli","text":"Visit the Ceramic CLI page for instructions on how to quickly install the CLI.","title":"1. Install the CLI"},{"location":"build/quick-start/#2-create-a-stream","text":"Use the create command to create a new stream . In the example below we create a stream that uses the TileDocument StreamType . Note that TileDocument is the only StreamType that can currently be created by the Ceramic CLI. Command $ ceramic create tile --content '{ \"Foo\": \"Bar\" }' Output StreamID ( kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa ) { \"Foo\" : \"Bar\" } The first line of the output is the StreamID , which is the persistent identifier of our newly created stream. This StreamID will be different for you, since you created it with your DID. Below the StreamID is the current content of the stream. More options --controllers : set the controller of the stream --schema : set the schema of the TileDocument Run ceramic create -h to see all available options","title":"2. Create a stream"},{"location":"build/quick-start/#3-query-a-stream","text":"Use the show command to query the current state of a stream. You will need to provide its StreamID . Command $ ceramic show kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa You should use your StreamID instead of the StreamID included here. Output { \"Foo\" : \"Bar\" } Use the state command to query the entire state of a stream. Command $ ceramic state kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa You should use your StreamID instead of the StreamID included here. Output before anchor { \"type\" : 0 , \"content\" : { \"Foo\" : \"Bar\" } , \"metadata\" : { \"unique\" : \"E4qPslUd0qo98TZX\" , \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/24/2021, 11:45:00 AM\" } Here we can see various information about the stream such as content , controllers , and schema . In your output you should see your local DID as the controller, instead of the DID we show here. You will also see a different randomly-generated \"unique\" string for any TileDocument that was created without the --deterministic flag. We can also see the current anchorStatus of our stream, and that it has been scheduled to be anchored at 11:45 on the 24 th of January 2021. Once this anchor is finalized, the state of the stream will automatically be updated with a new entry in the log and anchorStatus will be set to ANCHORED . Output after anchor { \"type\" : 0 , \"content\" : { \"Foo\" : \"Bar\" } , \"metadata\" : { \"unique\" : \"E4qPslUd0qo98TZX\" , \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"ANCHORED\" , \"log\" : [ { \"cid\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"type\" : 0 } , { \"cid\" : \"bafyreig6hostufw42cmz2cnn7hpvb6pau67a2n2syhzej7orqxfymdayyq\" , \"type\" : 2 } ] , \"anchorScheduledFor\" : null, \"anchorProof\" : { \"root\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"txHash\" : \"bagjqcgza4xgkpjodtqtgyu2fx6rdr6fb6mhevd5hy4253tl6pjlssidpwaha\" , \"chainId\" : \"eip155:3\" , \"blockNumber\" : 9527752 , \"blockTimestamp\" : 1611485094 } } This output was seen after the anchor has been created. The stream state has now shifted anchorStatus to ANCHORED . You can also see that the log contains one more entry.","title":"3. Query a stream"},{"location":"build/quick-start/#4-update-a-stream","text":"Use the update command to update a stream. Your DID must be the controller of the stream in order to update it. Note that TileDocument is the only StreamType that can currently be updated by the CLI. Command $ ceramic update kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa --content '{ \"Foo\": \"Baz\" }' You should use your StreamID instead of the StreamID included here. Output { \"Foo\" : \"Baz\" } More options Currently you can change content , controllers , and schema using the CLI. Run ceramic update -h for more information.","title":"4. Update a stream"},{"location":"build/quick-start/#5-create-a-schema","text":"TileDocuments can enforce that their contents adhere to a specified schema. The schemas themselves are TileDocuments where the content is a json-schema . For example we can create a schema that requires a TileDocument to have a title and message . Command $ ceramic create tile --content ' { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Reward\", \"type\": \"object\", \"properties\": { \"title\": { \"type\": \"string\" }, \"message\": { \"type\": \"string\" } }, \"required\": [ \"message\", \"title\" ] }' Output StreamID ( kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb ) { \"type\" : \"object\" , \"title\" : \"Reward\" , \" $schema \" : \"http://json-schema.org/draft-07/schema#\" , \"required\" : [ \"message\" , \"title\" ] , \"properties\" : { \"title\" : { \"type\" : \"string\" } , \"message\" : { \"type\" : \"string\" } } }","title":"5. Create a schema"},{"location":"build/quick-start/#6-create-a-tiledocument-stream-that-uses-a-schema","text":"First, use the commits command to list the commitIDs contained in the schema stream. When creating a TileDocument that uses this schema, we need to use a commitID instead of the StreamID to enforce that we are using a specific version of the schema since the schema stream is mutable and can be updated. Command $ ceramic commits kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb You should use your StreamID for the stream containing the json-schema you want to enforce, instead of the StreamID included here. Output [ \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" ] If a stream contains multiple commits and you're not sure which one you want, use the show command to show the content of the stream at the given commit. Once you retrieve the desired commit, you can now create a TileDocument that is enforced to conform to this version of the schema. Use the create command and pass the --schema option along with your commitID. Command $ ceramic create tile --content '{ \"title\": \"My first document with schema\", \"message\": \"Hello World\" }' --schema k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8 You should use your commitID instead of the commitID included here. Output StreamID ( kjzl6cwe1jw149tvfh6otqfzd2hfknkifb1z2lakozkicvau0xldzzdzwfbsztj ) { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" }","title":"6. Create a TileDocument stream that uses a schema"},{"location":"build/quick-start/#7-query-the-stream-you-created","text":"Use the state command to query the state of the TileDocument we just created. We can see that the schema is set to the correct commitID. Command $ ceramic state kjzl6cwe1jw14b5sr79heovz7fziz4dxcn8upx3bcesriloqcui137k6rq6g2mn You should use your StreamID instead of the StreamID included here. Output { \"type\" : 0 , \"content\" : { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" } , \"metadata\" : { \"unique\" : \"GR5tBtHdaw608esV\" , \"schema\" : \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" , \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera5qxg5zabjjvwpcbia6c3t6vebgo4brgmsagxezdjgk4vxnzwb5hq\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/13/2021, 1:45:00 PM\" }","title":"7. Query the stream you created"},{"location":"build/quick-start/#thats-it","text":"Congratulations on completing this tutorial! You're well on your way to becoming a Ceramic developer. Now let's install Ceramic in your project \u2192","title":"That's it!"},{"location":"build/share/","text":"Share your project \u00b6 Congratulations on making it this far! We're excited to see what you've built with Ceramic. To help the community discover your work: Add the ceramic topic to your project on Github Add your project to the Awesome Ceramic page on Github","title":"Share your work"},{"location":"build/share/#share-your-project","text":"Congratulations on making it this far! We're excited to see what you've built with Ceramic. To help the community discover your work: Add the ceramic topic to your project on Github Add your project to the Awesome Ceramic page on Github","title":"Share your project"},{"location":"build/troubleshooting/","text":"Troubleshooting \u00b6 Developer Chat \u00b6 For developer questions, chat, and support, join us on the Ceramic Discord . Github Issues \u00b6 For specific bugs, issues, and feature requests, create a Github issue on the appropriate repository. Before creating a new issue, please search existing issues to ensure your issue has not already been reported. If it has, just add a new comment to that issue explaining that you are encourering the same problem. Twitter \u00b6 For updates and news from the Ceramic ecosystem, follow Ceramic on Twitter .","title":"Troubleshooting"},{"location":"build/troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"build/troubleshooting/#developer-chat","text":"For developer questions, chat, and support, join us on the Ceramic Discord .","title":"Developer Chat"},{"location":"build/troubleshooting/#github-issues","text":"For specific bugs, issues, and feature requests, create a Github issue on the appropriate repository. Before creating a new issue, please search existing issues to ensure your issue has not already been reported. If it has, just add a new comment to that issue explaining that you are encourering the same problem.","title":"Github Issues"},{"location":"build/troubleshooting/#twitter","text":"For updates and news from the Ceramic ecosystem, follow Ceramic on Twitter .","title":"Twitter"},{"location":"build/writes/","text":"Writes \u00b6 Writes are interactions that write to Ceramic such as creating new streams or updating existing streams. You need an installed client and an authenticated user to perform writes. Usage \u00b6 Write operations are StreamType specific. The APIs for performing writes are contained within the various Stream implementations. See StreamTypes for information on how to perform writes for each of the supported StreamTypes.","title":"Writes"},{"location":"build/writes/#writes","text":"Writes are interactions that write to Ceramic such as creating new streams or updating existing streams. You need an installed client and an authenticated user to perform writes.","title":"Writes"},{"location":"build/writes/#usage","text":"Write operations are StreamType specific. The APIs for performing writes are contained within the various Stream implementations. See StreamTypes for information on how to perform writes for each of the supported StreamTypes.","title":"Usage"},{"location":"clients/javascript/cli/","text":"JS CLI Client \u00b6 The JS CLI allows you to start a JavaScript Ceramic node and interact with it from the command line. This page describes how to use the CLI for command line interactions. If you are looking to spin up a hosted node for other use cases such as for use with the JS HTTP Client or as a secondary node for redundant stream pinning and replication, see Hosting a node . Installation \u00b6 Installing the JS CLI requires a console, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may still be able to get it to work. You will need to install the node-pre-gyp package globally. This is required until node-webrtc which IPFS depends on is upgraded . npm install -g node-pre-gyp 1. Install the CLI \u00b6 Open your console and install the JS CLI using npm. npm install -g @ceramicnetwork/cli 2. Start the Ceramic node \u00b6 This starts a local Ceramic node on the Clay Testnet at https://localhost:7007 . $ ceramic daemon This localhost setup allows you to read streams from other nodes connected on the same network , but writes to your local node will only be available on your local node and on other nodes found on the peerlist . They will not be available to every node on the network. For greater connectivity, you might want to connect your CLI to a remote long-lived Ceramic node. 3. Configure a network (optional) \u00b6 By default, the JS CLI starts a node on the Clay Testnet . If you would like to use a different network, you can specify this using the --network option. View available networks . Note, the CLI can not yet be used with Mainnet . 4. Configure a node URL (optional) \u00b6 It is possible to use the CLI with a remote Ceramic node over HTTP, instead of a local node. To do this, use the config set command to set the ceramicHost variable to the URL of the node you wish to use. $ ceramic config set ceramicHost 'https://yourceramicnode.com' When using the CLI with a remote node, you have a few options: Free community nodes Commercial node providers Host your own node Authentication \u00b6 By default, the CLI is authenticated using the Key DID Provider . The seed for this DID is stored in ~/.ceramic/config.json . If this file is not present on startup a new DID will be randomly generated. It's currently not possible to use the Ceramic CLI with other DID methods. Usage \u00b6 Walk through core functionalities using the CLI with the Quick Start guide .","title":"CLI"},{"location":"clients/javascript/cli/#js-cli-client","text":"The JS CLI allows you to start a JavaScript Ceramic node and interact with it from the command line. This page describes how to use the CLI for command line interactions. If you are looking to spin up a hosted node for other use cases such as for use with the JS HTTP Client or as a secondary node for redundant stream pinning and replication, see Hosting a node .","title":"JS CLI Client"},{"location":"clients/javascript/cli/#installation","text":"Installing the JS CLI requires a console, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may still be able to get it to work. You will need to install the node-pre-gyp package globally. This is required until node-webrtc which IPFS depends on is upgraded . npm install -g node-pre-gyp","title":"Installation"},{"location":"clients/javascript/cli/#1-install-the-cli","text":"Open your console and install the JS CLI using npm. npm install -g @ceramicnetwork/cli","title":"1. Install the CLI"},{"location":"clients/javascript/cli/#2-start-the-ceramic-node","text":"This starts a local Ceramic node on the Clay Testnet at https://localhost:7007 . $ ceramic daemon This localhost setup allows you to read streams from other nodes connected on the same network , but writes to your local node will only be available on your local node and on other nodes found on the peerlist . They will not be available to every node on the network. For greater connectivity, you might want to connect your CLI to a remote long-lived Ceramic node.","title":"2. Start the Ceramic node"},{"location":"clients/javascript/cli/#3-configure-a-network-optional","text":"By default, the JS CLI starts a node on the Clay Testnet . If you would like to use a different network, you can specify this using the --network option. View available networks . Note, the CLI can not yet be used with Mainnet .","title":"3. Configure a network (optional)"},{"location":"clients/javascript/cli/#4-configure-a-node-url-optional","text":"It is possible to use the CLI with a remote Ceramic node over HTTP, instead of a local node. To do this, use the config set command to set the ceramicHost variable to the URL of the node you wish to use. $ ceramic config set ceramicHost 'https://yourceramicnode.com' When using the CLI with a remote node, you have a few options: Free community nodes Commercial node providers Host your own node","title":"4. Configure a node URL (optional)"},{"location":"clients/javascript/cli/#authentication","text":"By default, the CLI is authenticated using the Key DID Provider . The seed for this DID is stored in ~/.ceramic/config.json . If this file is not present on startup a new DID will be randomly generated. It's currently not possible to use the Ceramic CLI with other DID methods.","title":"Authentication"},{"location":"clients/javascript/cli/#usage","text":"Walk through core functionalities using the CLI with the Quick Start guide .","title":"Usage"},{"location":"clients/javascript/core/","text":"JS Core Client \u00b6 The JS Core Client allows you to run the full Ceramic protocol (API and node) directly in any JavaScript environment, such as in your tests, in fully client-side browser applications, or in node.js. Carefully read the considerations below to decide if the JS Core Client is right for your project. Most applications instead use the JS HTTP Client . Installation | Full API reference Considerations \u00b6 Maximal security and decentralization : The Ceramic Core client does not have trusted relationships with any external nodes. With Ceramic Core, streams that are written , queried , or pinned are verified in the local environment which is great if you need maximal security and decentralization in your application. Transitory data availability : Streams created with Ceramic Core will only be available on the network as long as this node remains online. For example for setups that use the Core Client directly in-browser, when your user closes the tab any stream created by that user will become unavailable on the network until the user opens the application again. For more resilient data availability you can always replicate and pin streams on secondary long-running nodes, or instead use the JS HTTP Client which relies on a remote node more likely to always be online. Setup complexity : You will need to configure an IPFS node which supports the dag-jose data format and ensure connectivity to the rest of the Ceramic network. See installation below for instructions on how to do this. Swap for JS HTTP Client at any time : The JS Core Client and the JS HTTP Client implement the same CeramicApi TypeScript interface, so swapping between clients is seamless and doesn't require changing your application logic; it only requires changing your setup. Installation \u00b6 Installing the JS Core Client requires a console, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may still be able to get it to work. Try installing the node-pre-gyp package globally. This is required until node-webrtc , which IPFS depends on, is upgraded . npm install -g node-pre-gyp 1. Install the Core client \u00b6 Open your console and install the JS Core Client using npm. npm install @ceramicnetwork/core 2. Import the Core client \u00b6 import Ceramic from '@ceramicnetwork/core' 3. Import IPFS with dag-jose \u00b6 Ceramic utilizes the dag-jose IPLD codec to format and store data in IPFS. import IPFS from 'ipfs-core' import dagJose from 'dag-jose' import { convert } from 'blockcodec-to-ipld-format' const dagJoseFormat = convert ( dagJose ) 4. Create an IPFS instance \u00b6 Create an instance of js-ipfs with dag-jose enabled. const ipfs = await Ipfs . create ({ ipld : { formats : [ dagJoseFormat ] } }) 5. Create a Ceramic instance \u00b6 Create an instance of Ceramic by passing ipfs and an optional configuration object. const ceramic = await Ceramic . create ( ipfs , config ) 6. Import DID resolvers \u00b6 Import resolvers for all DID methods that this Core Client will support. This should be inclusive of the DID Method that you will use for authentication , but should also include all other DID Methods for which your node could possibly need to verify signatures. Therefore, it is recommended that all Core Clients be able to resolve at least the did:3 and did:key DID methods. import KeyDidResolver from 'key-did-resolver' import ThreeIdResolver from '@ceramicnetwork/3id-did-resolver' 7. Create a DID instance \u00b6 Create a DID instance which wraps an instance of a DID resolver that includes all individual DID resolvers from the previous step. Optionally, it also includes a DID Provider if you intend to authenticate DIDs to allow writes to the network during runtime. import { DID } from 'dids' const resolver = { ... KeyDidResolver . getResolver (), ... ThreeIdResolver . getResolver ( ceramic ) } const did = new DID ({ resolver }) 8. Set DID instance on Core client \u00b6 ceramic . did = did Next steps \u00b6 After setting the DID instance on the Core client, your application will now be able to perform queries . If you need to perform writes, proceed to setting up authentication .","title":"Core Client"},{"location":"clients/javascript/core/#js-core-client","text":"The JS Core Client allows you to run the full Ceramic protocol (API and node) directly in any JavaScript environment, such as in your tests, in fully client-side browser applications, or in node.js. Carefully read the considerations below to decide if the JS Core Client is right for your project. Most applications instead use the JS HTTP Client . Installation | Full API reference","title":"JS Core Client"},{"location":"clients/javascript/core/#considerations","text":"Maximal security and decentralization : The Ceramic Core client does not have trusted relationships with any external nodes. With Ceramic Core, streams that are written , queried , or pinned are verified in the local environment which is great if you need maximal security and decentralization in your application. Transitory data availability : Streams created with Ceramic Core will only be available on the network as long as this node remains online. For example for setups that use the Core Client directly in-browser, when your user closes the tab any stream created by that user will become unavailable on the network until the user opens the application again. For more resilient data availability you can always replicate and pin streams on secondary long-running nodes, or instead use the JS HTTP Client which relies on a remote node more likely to always be online. Setup complexity : You will need to configure an IPFS node which supports the dag-jose data format and ensure connectivity to the rest of the Ceramic network. See installation below for instructions on how to do this. Swap for JS HTTP Client at any time : The JS Core Client and the JS HTTP Client implement the same CeramicApi TypeScript interface, so swapping between clients is seamless and doesn't require changing your application logic; it only requires changing your setup.","title":"Considerations"},{"location":"clients/javascript/core/#installation","text":"Installing the JS Core Client requires a console, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may still be able to get it to work. Try installing the node-pre-gyp package globally. This is required until node-webrtc , which IPFS depends on, is upgraded . npm install -g node-pre-gyp","title":"Installation"},{"location":"clients/javascript/core/#1-install-the-core-client","text":"Open your console and install the JS Core Client using npm. npm install @ceramicnetwork/core","title":"1. Install the Core client"},{"location":"clients/javascript/core/#2-import-the-core-client","text":"import Ceramic from '@ceramicnetwork/core'","title":"2. Import the Core client"},{"location":"clients/javascript/core/#3-import-ipfs-with-dag-jose","text":"Ceramic utilizes the dag-jose IPLD codec to format and store data in IPFS. import IPFS from 'ipfs-core' import dagJose from 'dag-jose' import { convert } from 'blockcodec-to-ipld-format' const dagJoseFormat = convert ( dagJose )","title":"3. Import IPFS with dag-jose"},{"location":"clients/javascript/core/#4-create-an-ipfs-instance","text":"Create an instance of js-ipfs with dag-jose enabled. const ipfs = await Ipfs . create ({ ipld : { formats : [ dagJoseFormat ] } })","title":"4. Create an IPFS instance"},{"location":"clients/javascript/core/#5-create-a-ceramic-instance","text":"Create an instance of Ceramic by passing ipfs and an optional configuration object. const ceramic = await Ceramic . create ( ipfs , config )","title":"5. Create a Ceramic instance"},{"location":"clients/javascript/core/#6-import-did-resolvers","text":"Import resolvers for all DID methods that this Core Client will support. This should be inclusive of the DID Method that you will use for authentication , but should also include all other DID Methods for which your node could possibly need to verify signatures. Therefore, it is recommended that all Core Clients be able to resolve at least the did:3 and did:key DID methods. import KeyDidResolver from 'key-did-resolver' import ThreeIdResolver from '@ceramicnetwork/3id-did-resolver'","title":"6. Import DID resolvers"},{"location":"clients/javascript/core/#7-create-a-did-instance","text":"Create a DID instance which wraps an instance of a DID resolver that includes all individual DID resolvers from the previous step. Optionally, it also includes a DID Provider if you intend to authenticate DIDs to allow writes to the network during runtime. import { DID } from 'dids' const resolver = { ... KeyDidResolver . getResolver (), ... ThreeIdResolver . getResolver ( ceramic ) } const did = new DID ({ resolver })","title":"7. Create a DID instance"},{"location":"clients/javascript/core/#8-set-did-instance-on-core-client","text":"ceramic . did = did","title":"8. Set DID instance on Core client"},{"location":"clients/javascript/core/#next-steps","text":"After setting the DID instance on the Core client, your application will now be able to perform queries . If you need to perform writes, proceed to setting up authentication .","title":"Next steps"},{"location":"clients/javascript/http/","text":"JS HTTP Client \u00b6 The JS HTTP Client is a lightweight way of interacting with Ceramic. It allows your JavaScript application to connect to a remote Ceramic node over HTTP to read , write , and pin streams. The main decision to make when using the JS HTTP Client is which remote Ceramic node to use. The JS HTTP client is recommended when building most applications. Installation | Full API reference Considerations \u00b6 Improved performance : When using the JS HTTP Client, stream processing and validation happens on a remote Ceramic node running on a server, which usually results in improved performance compared to running the full protocol in-browser with the JS Core Client . Predictable data availability : Streams created using the JS HTTP Client can be pinned and made available on a remote Ceramic node which has more uptime and predictable data availability guarantees than, say, running the JS Core Client directly in-browser where users can open and close tabs causing their streams to come on and offline at unpredictable intervals. Some trust in a remote node : Stream processing and state validation happens on a remote node which the JS HTTP Client trusts. However, it is important to note that user's keys always live client-side and all updates are signed on the JS HTTP Client and then sent to the HTTP endpoint for processing. Swap for the JS Core Client at anytime : The JS HTTP Client and the JS Core Client implement the same CeramicApi TypeScript interface, so swapping between clients is seamless and doesn't require changing your application logic; it only requires changing your setup. Installation \u00b6 Installing the JS HTTP Client requires a console, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may still be able to get it to work. However you will need to install the node-pre-gyp package globally. This is required until node-webrtc , which IPFS depends on, is upgraded . npm install -g node-pre-gyp 1. Install the HTTP client \u00b6 Open your console and install the JS HTTP Client using npm. npm install @ceramicnetwork/http-client 2. Import the HTTP client \u00b6 import CeramicClient from '@ceramicnetwork/http-client' 3. Configure your node URL \u00b6 const API_URL = \"https://yourceramicnode.com\" Available options for your node setup: Free community nodes : Discover free HTTP endpoints Commercial node providers : Discover paid node providers Host your own node : Learn how to setup and host your own node localhost : You may want to use the JS HTTP Client with a Ceramic node running on your local machine for development and testing. To achieve this, first start a local daemon by installing the CLI . Once the CLI is installed, you can pass https://localhost:7007 to the HTTP client. This setup will allow you to read streams from other nodes connected on the Ceramic network, but writes to your local node will only be available on nodes found on the peerlist . For now, these streams will not be available to other nodes on the network due to a limitation in js-ipfs which will be fixed in the future. 4. Create a Ceramic instance \u00b6 const ceramic = new CeramicClient ( API_URL ) 5. Import DID resolvers \u00b6 Import the DID resolvers for all DID methods that will need to authenticate to perform writes using this HTTP Client. If your HTTP Client will only perform queries, then jump ahead to the queries page. import KeyDidResolver from 'key-did-resolver' import ThreeIdResolver from '@ceramicnetwork/3id-did-resolver' 6. Create a DID instance \u00b6 Create a DID instance which wraps an instance of a DID resolver that includes all individual DID resolvers from the previous step. It should also include a DID Provider for the DID Method you are using for authentication . import { DID } from 'dids' const resolver = { ... KeyDidResolver . getResolver (), ... ThreeIdResolver . getResolver ( ceramic ) } const did = new DID ({ resolver }) 7. Set DID instance on HTTP client \u00b6 ceramic . did = did Next steps \u00b6 If your application needs to perform writes, proceed to setting up authentication so users can perform writes using a DID. If your app only needs to perform queries, then jump ahead to queries .","title":"HTTP Client"},{"location":"clients/javascript/http/#js-http-client","text":"The JS HTTP Client is a lightweight way of interacting with Ceramic. It allows your JavaScript application to connect to a remote Ceramic node over HTTP to read , write , and pin streams. The main decision to make when using the JS HTTP Client is which remote Ceramic node to use. The JS HTTP client is recommended when building most applications. Installation | Full API reference","title":"JS HTTP Client"},{"location":"clients/javascript/http/#considerations","text":"Improved performance : When using the JS HTTP Client, stream processing and validation happens on a remote Ceramic node running on a server, which usually results in improved performance compared to running the full protocol in-browser with the JS Core Client . Predictable data availability : Streams created using the JS HTTP Client can be pinned and made available on a remote Ceramic node which has more uptime and predictable data availability guarantees than, say, running the JS Core Client directly in-browser where users can open and close tabs causing their streams to come on and offline at unpredictable intervals. Some trust in a remote node : Stream processing and state validation happens on a remote node which the JS HTTP Client trusts. However, it is important to note that user's keys always live client-side and all updates are signed on the JS HTTP Client and then sent to the HTTP endpoint for processing. Swap for the JS Core Client at anytime : The JS HTTP Client and the JS Core Client implement the same CeramicApi TypeScript interface, so swapping between clients is seamless and doesn't require changing your application logic; it only requires changing your setup.","title":"Considerations"},{"location":"clients/javascript/http/#installation","text":"Installing the JS HTTP Client requires a console, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may still be able to get it to work. However you will need to install the node-pre-gyp package globally. This is required until node-webrtc , which IPFS depends on, is upgraded . npm install -g node-pre-gyp","title":"Installation"},{"location":"clients/javascript/http/#1-install-the-http-client","text":"Open your console and install the JS HTTP Client using npm. npm install @ceramicnetwork/http-client","title":"1. Install the HTTP client"},{"location":"clients/javascript/http/#2-import-the-http-client","text":"import CeramicClient from '@ceramicnetwork/http-client'","title":"2. Import the HTTP client"},{"location":"clients/javascript/http/#3-configure-your-node-url","text":"const API_URL = \"https://yourceramicnode.com\" Available options for your node setup: Free community nodes : Discover free HTTP endpoints Commercial node providers : Discover paid node providers Host your own node : Learn how to setup and host your own node localhost : You may want to use the JS HTTP Client with a Ceramic node running on your local machine for development and testing. To achieve this, first start a local daemon by installing the CLI . Once the CLI is installed, you can pass https://localhost:7007 to the HTTP client. This setup will allow you to read streams from other nodes connected on the Ceramic network, but writes to your local node will only be available on nodes found on the peerlist . For now, these streams will not be available to other nodes on the network due to a limitation in js-ipfs which will be fixed in the future.","title":"3. Configure your node URL"},{"location":"clients/javascript/http/#4-create-a-ceramic-instance","text":"const ceramic = new CeramicClient ( API_URL )","title":"4. Create a Ceramic instance"},{"location":"clients/javascript/http/#5-import-did-resolvers","text":"Import the DID resolvers for all DID methods that will need to authenticate to perform writes using this HTTP Client. If your HTTP Client will only perform queries, then jump ahead to the queries page. import KeyDidResolver from 'key-did-resolver' import ThreeIdResolver from '@ceramicnetwork/3id-did-resolver'","title":"5. Import DID resolvers"},{"location":"clients/javascript/http/#6-create-a-did-instance","text":"Create a DID instance which wraps an instance of a DID resolver that includes all individual DID resolvers from the previous step. It should also include a DID Provider for the DID Method you are using for authentication . import { DID } from 'dids' const resolver = { ... KeyDidResolver . getResolver (), ... ThreeIdResolver . getResolver ( ceramic ) } const did = new DID ({ resolver })","title":"6. Create a DID instance"},{"location":"clients/javascript/http/#7-set-did-instance-on-http-client","text":"ceramic . did = did","title":"7. Set DID instance on HTTP client"},{"location":"clients/javascript/http/#next-steps","text":"If your application needs to perform writes, proceed to setting up authentication so users can perform writes using a DID. If your app only needs to perform queries, then jump ahead to queries .","title":"Next steps"},{"location":"explore/explorers/","text":"Explorers \u00b6 Discover various explorers for the Ceramic Network. Tiles \u00b6 Tiles : A browser-based explorer where you can see a feed of all streams created on the network, and dive into the details of any particular stream.","title":"Explorers"},{"location":"explore/explorers/#explorers","text":"Discover various explorers for the Ceramic Network.","title":"Explorers"},{"location":"explore/explorers/#tiles","text":"Tiles : A browser-based explorer where you can see a feed of all streams created on the network, and dive into the details of any particular stream.","title":"Tiles"},{"location":"explore/projects/","text":"Community projects \u00b6 This page contains a list of community projects built on Ceramic. Featured projects \u00b6 Boardroom (coming soon) \u00b6 Governance forums : BoardRoom uses Ceramic, IDX , and 3ID Connect to store proposals, comments, votes, and other user-generated content for their decentralized governance application. GeoWeb (coming soon) \u00b6 Mutable NFT files : GeoWeb uses Ceramic with the NFT DID method to store editable NFT files that can only be updated by the asset's current owner. When the assets transfers ownership on-chain, so do the write permissions automatically. MetaGame (coming soon) \u00b6 Multi-app user profiles : MetaGame uses Ceramic, IDX , and 3ID Connect to store profile data for Ethereum users that can be consumed, added to, or extended by any app in the Web3 metaverse. ArcX (coming soon) \u00b6 Decentralized document database : ArcX uses Ceramic to store mutable JSON documents, similar to a NoSQL document store. Daemon.Land (coming soon) \u00b6 Multi-app data : Developers on the Daemon.Land platform use Ceramic and IDX to store user data, which makes it easy for users and their data to freely travel between different apps built with Daemon.Land. RabbitHole (coming soon) \u00b6 Cross-chain identity and reputation : RabbitHole uses Ceramic, IDX , and 3ID Connect to link multiple Web3 wallets and Web2 accounts to a unified, cross-chain DID. After calculating an aggregate reputation score for this DID, they issue and store a verifiable credential in the user's IDX so it's usable on any other Web3 application. More projects \u00b6 See Awesome Ceramic for a list of community projects built on Ceramic.","title":"Projects"},{"location":"explore/projects/#community-projects","text":"This page contains a list of community projects built on Ceramic.","title":"Community projects"},{"location":"explore/projects/#featured-projects","text":"","title":"Featured projects"},{"location":"explore/projects/#boardroom-coming-soon","text":"Governance forums : BoardRoom uses Ceramic, IDX , and 3ID Connect to store proposals, comments, votes, and other user-generated content for their decentralized governance application.","title":"Boardroom (coming soon)"},{"location":"explore/projects/#geoweb-coming-soon","text":"Mutable NFT files : GeoWeb uses Ceramic with the NFT DID method to store editable NFT files that can only be updated by the asset's current owner. When the assets transfers ownership on-chain, so do the write permissions automatically.","title":"GeoWeb (coming soon)"},{"location":"explore/projects/#metagame-coming-soon","text":"Multi-app user profiles : MetaGame uses Ceramic, IDX , and 3ID Connect to store profile data for Ethereum users that can be consumed, added to, or extended by any app in the Web3 metaverse.","title":"MetaGame (coming soon)"},{"location":"explore/projects/#arcx-coming-soon","text":"Decentralized document database : ArcX uses Ceramic to store mutable JSON documents, similar to a NoSQL document store.","title":"ArcX (coming soon)"},{"location":"explore/projects/#daemonland-coming-soon","text":"Multi-app data : Developers on the Daemon.Land platform use Ceramic and IDX to store user data, which makes it easy for users and their data to freely travel between different apps built with Daemon.Land.","title":"Daemon.Land (coming soon)"},{"location":"explore/projects/#rabbithole-coming-soon","text":"Cross-chain identity and reputation : RabbitHole uses Ceramic, IDX , and 3ID Connect to link multiple Web3 wallets and Web2 accounts to a unified, cross-chain DID. After calculating an aggregate reputation score for this DID, they issue and store a verifiable credential in the user's IDX so it's usable on any other Web3 application.","title":"RabbitHole (coming soon)"},{"location":"explore/projects/#more-projects","text":"See Awesome Ceramic for a list of community projects built on Ceramic.","title":"More projects"},{"location":"explore/sample-apps/","text":"Sample Apps \u00b6 Simple demo applications to give you a sense of what's possible with Ceramic. Playground : A minimal browser application that integrates the Ceramic JS HTTP client, 3ID Connect , and IDX .","title":"Sample apps"},{"location":"explore/sample-apps/#sample-apps","text":"Simple demo applications to give you a sense of what's possible with Ceramic. Playground : A minimal browser application that integrates the Ceramic JS HTTP client, 3ID Connect , and IDX .","title":"Sample Apps"},{"location":"learn/blog/","text":"Ceramic Blog \u00b6 The Ceramic Blog contains news, announcements, videos, as well as helpful tutorials and resources for building with Ceramic. Check it out to get inspired for your next project. Featured posts \u00b6 What is Ceramic : Ceramic is a decentralized content computation network for a world of open source information. Ceramic Mainnet Early Launch Program : Sign up today to deploy your project on the Ceramic Mainnet before it's open to the general public. How to build a simple notes app with IDX : Learn how to build a simple note taking application where users own their data with IDX and React. How to store signed and encrypted data on IPFS : Learn how to store signed and encrypted data directly in IPFS using two new standards: dag-jose and EIP-2844. Trust minimized off-chain conviction voting : How to implement a conviction voting system using verifiable, off-chain data on Ceramic. Featured videos \u00b6 Learn how to manage user data in a Web3 app with IDX : Learn how to manage user data for your Web3 application with IDX. This talk is a workshop from tthe ETHDenver 2021 hackathon. Standards for encrypted and mutable data on IPFS : Joel talks about new standards for signed, encrypted, mutable data on IPFS. This is a talk from the ETHDenver 2021 hackathon. The evolution of digital identity : Michael talks about the evolution of digital identity from servers, to key pairs, to DIDs and IDX. A presentation from the ETHDever 2021 hackathon.","title":"Blog"},{"location":"learn/blog/#ceramic-blog","text":"The Ceramic Blog contains news, announcements, videos, as well as helpful tutorials and resources for building with Ceramic. Check it out to get inspired for your next project.","title":"Ceramic Blog"},{"location":"learn/blog/#featured-posts","text":"What is Ceramic : Ceramic is a decentralized content computation network for a world of open source information. Ceramic Mainnet Early Launch Program : Sign up today to deploy your project on the Ceramic Mainnet before it's open to the general public. How to build a simple notes app with IDX : Learn how to build a simple note taking application where users own their data with IDX and React. How to store signed and encrypted data on IPFS : Learn how to store signed and encrypted data directly in IPFS using two new standards: dag-jose and EIP-2844. Trust minimized off-chain conviction voting : How to implement a conviction voting system using verifiable, off-chain data on Ceramic.","title":"Featured posts"},{"location":"learn/blog/#featured-videos","text":"Learn how to manage user data in a Web3 app with IDX : Learn how to manage user data for your Web3 application with IDX. This talk is a workshop from tthe ETHDenver 2021 hackathon. Standards for encrypted and mutable data on IPFS : Joel talks about new standards for signed, encrypted, mutable data on IPFS. This is a talk from the ETHDenver 2021 hackathon. The evolution of digital identity : Michael talks about the evolution of digital identity from servers, to key pairs, to DIDs and IDX. A presentation from the ETHDever 2021 hackathon.","title":"Featured videos"},{"location":"learn/data-availability/","text":"Data Availability \u00b6 This page describes the data persistence and data availability model for streams on Ceramic. Overview \u00b6 Stream data can be divided into two main categories: commits and state . While there is some overlap, these two types of data have enough difference that they should be considered separately when planning how to persist and host your streams. All commits and state for a given stream must be available when performing writes or queries on that stream; if not, your client will return an error. This error will disappear once all data comes back online. In the event that one or more commits for the given stream were permanently lost due to improper persistence management, then this stream will be corrupted and the error will not disappear. Stream commits \u00b6 Every stream is an event log consisting of one of more commits, and each commit contains of at least two IPLD objects. Collectively these commits store the data that makes up the content of a stream. Caching \u00b6 Ceramic nodes have a built-in caching mechanism for short-term storage of commits. Whenever a Ceramic node performs a write or a query on a stream, all commits for that stream are first synced from the network and automatically loaded into that node's in-memory cache. This results in the most popular streams being replicated the most, providing some level of data persistence and availability. However to preserve disk space and node resources, in-memory cache defaults to a limit of 500 streams (but can be configured to any number). Once that number is reached, the oldest streams will be evicted from the node's cache in order to make room for newer ones. If the node happens to shut down or restart, the cache will be cleared. Without sufficient replication across other nodes due to popularity or additional data persistence measures prior to a shutdown, streams that only exist in-memory will be lost forever. Therefore, cache-only is not a dependable source of data availability for a longer period than a specific session. Pinning \u00b6 Pinning provides a more long-lived mechanism of data persistence for commits. Pinning is a process for instructing a Ceramic node to explicitly host (i.e. \"pin\") the commits for a specific stream. Since commits are stored in IPLD, Ceramic nodes already contain a bundled IPFS node which is where this pinning occurs. IPFS nodes can pin all commits for any stream which is accessible over the Ceramic network to which it is connected. Ceramic pinning can also work using an external IPFS node instead of the bundled internal version. If developers want the easiest way to make their streams persistent beyond a single session and more resilient against data loss, then pinning is the right option. Ceramic nodes can pin an unlimited number of streams. However, note that if only one IPFS node is pinning a given stream and it disappears forever or gets corrupted, then that stream will be lost. Also, if only one node is pinning a stream (and no other Ceramic nodes have it in cache) and that node goes offline, then that stream will be unavailable to others. Therefore, for improved resilience and data availability it is best to have multiple IPFS nodes running in different envitonments pinning the same streams. See the Pinning guide for instructions on how to pin streams on a Ceramic node. Archiving \u00b6 Archiving is the most durable, long-lived form of persistence for commits. In addition to caching and pinning, Ceramic developers may also configure their node to connect to an external service for archiving all commits that make up a stream. The exact guarantees provided by archiving differ with each implementation and service provider. For example, archiving to Filecoin provides crypto-economically guaranteed data availability with a pay-as-you-go model, while archiving to Arweave provides crypto-economically guaranteed data availability with a one-time payment model. Conversely, archiving to Amazon S3 provides a simpler model however Amazon cannot guarantee that your data will always be available (for example you could stop paying your bill), but the storage is still more resilient than using pinning and caching only. Stream state \u00b6 In addition to the commit log mentioned above which is stored in IPFS, every stream has a state which is not stored in IPFS but rather is collectively tracked, persisted, and made available by all Ceramic nodes that are caching and/or pinning the stream. Both the complete commit history and the state are needed to successfully load and interact with streams. Caching \u00b6 State caching works the same as commit caching. Pinning \u00b6 State pinning works the same as commit pinning, except state pinning does not occur on IPFS. State pinning simply occurs in a database internal to the Ceramic node. Archiving \u00b6 Ceramic is working on a durable, decentralized state store which will be used to persist and guarantee availability for the state of streams. This is on the roadmap. It's not critical to the immediate use of Ceramic, but will serve to make state more resilient and available. In the meantime, Ceramic supports archiving state to Amazon S3, for an option with more durability and reliability than the local database used by default.","title":"Data availability"},{"location":"learn/data-availability/#data-availability","text":"This page describes the data persistence and data availability model for streams on Ceramic.","title":"Data Availability"},{"location":"learn/data-availability/#overview","text":"Stream data can be divided into two main categories: commits and state . While there is some overlap, these two types of data have enough difference that they should be considered separately when planning how to persist and host your streams. All commits and state for a given stream must be available when performing writes or queries on that stream; if not, your client will return an error. This error will disappear once all data comes back online. In the event that one or more commits for the given stream were permanently lost due to improper persistence management, then this stream will be corrupted and the error will not disappear.","title":"Overview"},{"location":"learn/data-availability/#stream-commits","text":"Every stream is an event log consisting of one of more commits, and each commit contains of at least two IPLD objects. Collectively these commits store the data that makes up the content of a stream.","title":"Stream commits"},{"location":"learn/data-availability/#caching","text":"Ceramic nodes have a built-in caching mechanism for short-term storage of commits. Whenever a Ceramic node performs a write or a query on a stream, all commits for that stream are first synced from the network and automatically loaded into that node's in-memory cache. This results in the most popular streams being replicated the most, providing some level of data persistence and availability. However to preserve disk space and node resources, in-memory cache defaults to a limit of 500 streams (but can be configured to any number). Once that number is reached, the oldest streams will be evicted from the node's cache in order to make room for newer ones. If the node happens to shut down or restart, the cache will be cleared. Without sufficient replication across other nodes due to popularity or additional data persistence measures prior to a shutdown, streams that only exist in-memory will be lost forever. Therefore, cache-only is not a dependable source of data availability for a longer period than a specific session.","title":"Caching"},{"location":"learn/data-availability/#pinning","text":"Pinning provides a more long-lived mechanism of data persistence for commits. Pinning is a process for instructing a Ceramic node to explicitly host (i.e. \"pin\") the commits for a specific stream. Since commits are stored in IPLD, Ceramic nodes already contain a bundled IPFS node which is where this pinning occurs. IPFS nodes can pin all commits for any stream which is accessible over the Ceramic network to which it is connected. Ceramic pinning can also work using an external IPFS node instead of the bundled internal version. If developers want the easiest way to make their streams persistent beyond a single session and more resilient against data loss, then pinning is the right option. Ceramic nodes can pin an unlimited number of streams. However, note that if only one IPFS node is pinning a given stream and it disappears forever or gets corrupted, then that stream will be lost. Also, if only one node is pinning a stream (and no other Ceramic nodes have it in cache) and that node goes offline, then that stream will be unavailable to others. Therefore, for improved resilience and data availability it is best to have multiple IPFS nodes running in different envitonments pinning the same streams. See the Pinning guide for instructions on how to pin streams on a Ceramic node.","title":"Pinning"},{"location":"learn/data-availability/#archiving","text":"Archiving is the most durable, long-lived form of persistence for commits. In addition to caching and pinning, Ceramic developers may also configure their node to connect to an external service for archiving all commits that make up a stream. The exact guarantees provided by archiving differ with each implementation and service provider. For example, archiving to Filecoin provides crypto-economically guaranteed data availability with a pay-as-you-go model, while archiving to Arweave provides crypto-economically guaranteed data availability with a one-time payment model. Conversely, archiving to Amazon S3 provides a simpler model however Amazon cannot guarantee that your data will always be available (for example you could stop paying your bill), but the storage is still more resilient than using pinning and caching only.","title":"Archiving"},{"location":"learn/data-availability/#stream-state","text":"In addition to the commit log mentioned above which is stored in IPFS, every stream has a state which is not stored in IPFS but rather is collectively tracked, persisted, and made available by all Ceramic nodes that are caching and/or pinning the stream. Both the complete commit history and the state are needed to successfully load and interact with streams.","title":"Stream state"},{"location":"learn/data-availability/#caching_1","text":"State caching works the same as commit caching.","title":"Caching"},{"location":"learn/data-availability/#pinning_1","text":"State pinning works the same as commit pinning, except state pinning does not occur on IPFS. State pinning simply occurs in a database internal to the Ceramic node.","title":"Pinning"},{"location":"learn/data-availability/#archiving_1","text":"Ceramic is working on a durable, decentralized state store which will be used to persist and guarantee availability for the state of streams. This is on the roadmap. It's not critical to the immediate use of Ceramic, but will serve to make state more resilient and available. In the meantime, Ceramic supports archiving state to Amazon S3, for an option with more durability and reliability than the local database used by default.","title":"Archiving"},{"location":"learn/features/","text":"Features \u00b6 Ceramic is a decentralized, open source platform for creating, hosting, and sharing streams of data. With Ceramic's permissionless data streaming network, you can store streams of information and ever-changing files directly on the decentralized web \u2013 and share updates with anyone in the world. This page describes the most important features of the protocol. Mutable streams \u00b6 Store, edit, and update continuous streams of content or ever-changing files using stateful data structures on IPFS (specifically IPLD ). The data structure of your streams can be fully customized to your specific use cases and needs. Immutable naming \u00b6 Reference streams by a persistent identifier, called a StreamID , instead of needing to keep track of IPFS CIDs that change every time your content does. Tamper-proof history \u00b6 Inspect, audit, or time travel through the complete history of any stream to see how its content has changed over time. Global availability \u00b6 Host and make your streams available over a decentralized, global, peer-to-peer network that is censorship-resistant and completely free of middlemen. Sync & share \u00b6 Query, sync, or subscribe to any stream on the network using standardized APIs, making it easy to share data across organizational boundaries. Whenever you or anyone else syncs your streams from the network, they will always get back the most current state. Limitless composability \u00b6 All streams on Ceramic exist within a single global namespace, allowing you to reference and aggregate multiple streams into higher-order compositions or fork and remix existing streams into entirely new creations. Custom functions \u00b6 Write custom functions for processing updates to your stream's state . These functions are called StreamTypes , and they're deployed to a Ceramic node . StreamTypes ingest new updates and autonomously apply transformations to your stream \u2013 guaranteeing data consistency and integrity without needing to rely on an external source of compute logic or state management. Ceramic nodes come prepackaged with common StreamTypes making it easy to get started creating applications without needing to code your own. DID authentication \u00b6 Authenticate to and transact with streams using W3C-standard decentralized identities ( DIDs ). While every StreamType is able to define its own authentication requirements and mechanisms, DIDs are the most common. Notably DIDs can be controlled with one or more Web3/blockchain wallets, so your users can build up a unified cross-chain Web3 identity using the wallets they already have. Scalable consensus \u00b6 Unlike blockchains or other DLT systems which have scalability limitations due to reliances on a single execution environment and global state, Ceramic takea a different approach to network scalability. On Ceramic, every stream maintains its own state and nodes independently process stream transactions, allowing for unbounded parallelization. This enables Ceramic to operate at worldwide data scale, which is orders of magnitude greater than the scale needed for decentralized finance. Archive anywhere \u00b6 Backup the contents of your stream to IPFS, Filecoin, or Amazon S3. Visit Data Availability to learn more about the data persistence and availability model of Ceramic.","title":"Features"},{"location":"learn/features/#features","text":"Ceramic is a decentralized, open source platform for creating, hosting, and sharing streams of data. With Ceramic's permissionless data streaming network, you can store streams of information and ever-changing files directly on the decentralized web \u2013 and share updates with anyone in the world. This page describes the most important features of the protocol.","title":"Features"},{"location":"learn/features/#mutable-streams","text":"Store, edit, and update continuous streams of content or ever-changing files using stateful data structures on IPFS (specifically IPLD ). The data structure of your streams can be fully customized to your specific use cases and needs.","title":"Mutable streams"},{"location":"learn/features/#immutable-naming","text":"Reference streams by a persistent identifier, called a StreamID , instead of needing to keep track of IPFS CIDs that change every time your content does.","title":"Immutable naming"},{"location":"learn/features/#tamper-proof-history","text":"Inspect, audit, or time travel through the complete history of any stream to see how its content has changed over time.","title":"Tamper-proof history"},{"location":"learn/features/#global-availability","text":"Host and make your streams available over a decentralized, global, peer-to-peer network that is censorship-resistant and completely free of middlemen.","title":"Global availability"},{"location":"learn/features/#sync-share","text":"Query, sync, or subscribe to any stream on the network using standardized APIs, making it easy to share data across organizational boundaries. Whenever you or anyone else syncs your streams from the network, they will always get back the most current state.","title":"Sync &amp; share"},{"location":"learn/features/#limitless-composability","text":"All streams on Ceramic exist within a single global namespace, allowing you to reference and aggregate multiple streams into higher-order compositions or fork and remix existing streams into entirely new creations.","title":"Limitless composability"},{"location":"learn/features/#custom-functions","text":"Write custom functions for processing updates to your stream's state . These functions are called StreamTypes , and they're deployed to a Ceramic node . StreamTypes ingest new updates and autonomously apply transformations to your stream \u2013 guaranteeing data consistency and integrity without needing to rely on an external source of compute logic or state management. Ceramic nodes come prepackaged with common StreamTypes making it easy to get started creating applications without needing to code your own.","title":"Custom functions"},{"location":"learn/features/#did-authentication","text":"Authenticate to and transact with streams using W3C-standard decentralized identities ( DIDs ). While every StreamType is able to define its own authentication requirements and mechanisms, DIDs are the most common. Notably DIDs can be controlled with one or more Web3/blockchain wallets, so your users can build up a unified cross-chain Web3 identity using the wallets they already have.","title":"DID authentication"},{"location":"learn/features/#scalable-consensus","text":"Unlike blockchains or other DLT systems which have scalability limitations due to reliances on a single execution environment and global state, Ceramic takea a different approach to network scalability. On Ceramic, every stream maintains its own state and nodes independently process stream transactions, allowing for unbounded parallelization. This enables Ceramic to operate at worldwide data scale, which is orders of magnitude greater than the scale needed for decentralized finance.","title":"Scalable consensus"},{"location":"learn/features/#archive-anywhere","text":"Backup the contents of your stream to IPFS, Filecoin, or Amazon S3. Visit Data Availability to learn more about the data persistence and availability model of Ceramic.","title":"Archive anywhere"},{"location":"learn/glossary/","text":"Glossary of terms \u00b6 This page contains a glossary of terms for Ceramic. Consider this list a work-in-progress; we will continue to update it until it's complete. Core concepts \u00b6 Streams \u00b6 Streams are DAG-based data structures for storing continuous, mutable streams of content on IPFS and tracking state in a completely decentralized, peer-to-peer way. When syncing or loading a stream from the network , you will always get back the current state. StreamID \u00b6 A StreamID is an immutable identifier for a stream . StreamIDs enable continuous streams of data to be referenced by a persistent identifier instead of by constantly-changing IPFS CIDs . StreamTypes \u00b6 StreamTypes are functions used for processing updates to streams . StreamTypes handle everything from defining the data structure of the stream, to what can be stored in its commits , its state transitition function, authentication requirements, and conflict resolution strategy . Every stream must specify a StreamType; and StreamTypes run on Ceramic nodes . Ceramic comes pre-installed with various StreamTypes , or you can code your own. Commits \u00b6 Commits are individual IPFS records that make up a stream . Streams may contain one or more commits. Genesis commit \u00b6 A genesis commit is the first commit in a stream . Genesis commits may be signed by a public key, or unsigned. Signed commit \u00b6 Signed commits are commits that update the state of a stream . All signed commits need to be cryptographically signed by a public key. Anchor commit \u00b6 Anchor commits are commits that contain a blockchain timestamp, providing an immutable record of time and ordering to other commits in the stream , sometimes known as a proof-of-publication . CommitID \u00b6 A commitID is an immutable identifier for a specific commit in a stream . State \u00b6 State represents the state of a stream at various points in time. When a stream is loaded or queried from the network , the current state is returned. Tip \u00b6 A tip is the CID for the most recent commit(s) of a stream . Conflict resolution strategy \u00b6 A conflict resolution strategy is logic defined by a StreamType that describes how the protocol should handle conflicting updates to a stream that uses this StreamType. Controllers \u00b6 Controllers are entities allowed to perform updates to a stream , by creating new signed commits . A given stream may have one or more controllers. Stream authentication \u00b6 Authentication \u00b6 Authentication allows a user to perform protected operations on a stream, such as creating genesis commits , signed commits , or decrypting data. Each StreamType implementation is able to specify its own authentication mechanism as long as the signatures can be resolved/validated by Ceramic, but most StreamTypes use DIDs . DIDs \u00b6 DIDs is the W3C standard for decentralized identifiers. The DID specification outlines a standard URI scheme for creating a persistent decentralized identifier (DID) for a given subject as well as resolving metadata about that identifier via a DID document . DIDs are used as an authentication mechanism by most StreamTypes . DID methods \u00b6 DID methods are implementations of the DID specification. DID methods must specify a name for the method in the form of a string (see below), a description of where the DID document is stored (or how it is statically generated), and a DID resolver which can return a DID document given a URI that conforms to that particular DID method. There are over 40 DID methods on the W3C's official DID registry. Ceramic can support any DID method if needed, and currently supports the 3ID DID method and the Key DID method . DID URIs look like this: did:<method-name>:<method-specific-identifier> DID document \u00b6 DID documents are documents which contain metadata about a given DID. At a minimum they should contain cryptographic key material used for signature verification and encryption/decryption. They may be mutable where their keys and content can be changed/rotated (i.e. 3ID DID method ) or statically generated where their contents cannot be manually changed (i.e. Key DID method ). DID resolver \u00b6 DID resolvers are software libraries responsible for returning a DID document given a DID string. Each DID method has at least one resolver implementation. For all DID methods supported by Ceramic, the corresponding DID resolver must be included in a Ceramic node . DID providers \u00b6 DID providers are software libraries that allow developers or other programs to create, manage, and use DIDs that conform to a particular DID method . When using Ceramic with streams that require DIDs for authentication , applications either need to integrate a DID provider library, which leaves the responsibility of key management up to the application, or a DID wallet , which is a more user-friendly experience. DID wallets \u00b6 DID wallets are software libraries or end-user applications that wrap DID providers with additional capabilities. 3ID Connect is the most popular DID wallet SDK that allows users create, manage, and use a 3ID DID method with their existing blockchain wallets, and without needing to install any additional software. Network \u00b6 Clients \u00b6 Clients are software libraries that provide developer interfaces to a Ceramic node . Clients are responsible for authenticating users , providing StreamType -specific interfaces for generating genesis commits and signed commits , and providing generic, streamtype-agnostic interfaces for loading or querying streams. A list of Ceramic clients can be found here . Nodes \u00b6 Nodes are software libraries that provide core protocol functionality for the Ceramic network . Nodes are responsible for processing stream updates (in the form of signed commits from clients ), storing state for the streams that it cares about, responding to queries, networking with other nodes, replicating streams across the network, and sending valid signed commits to an external anchor service for generating anchor commits . Anchor service \u00b6 Anchor services are hosted \"layer-2\" services for Ceramic that generate anchor commits for many different streams in a scalable, low cost manner by batching many different stream transactions into a merkle tree, and including the merkle root into a transaction on a blockchain platform (currently Ethereum ). This eliminates the need for each stream transaction to have its own corresponding blockchain transaction, which would be slower and more expensive. Networks \u00b6 Networks are collections of Ceramic nodes that share specific configurations and communicate over a dedicated libp2p topic. Networks are discrete from one another. Streams that exist on one network are not discoverable on or portable to another. Currently, Ceramic has three primary networks: mainnet , Clay Testnet , and dev unstable . Mainnet \u00b6 Mainnet is the Ceramic network used for production deployments. For more information on mainnet, see the Networks page. Clay Testnet \u00b6 Clay Testnet is a Ceramic network used by the community for application prototyping, development, and testing purposes. Ceramic core devs also use Clay for testing official protocol release candidates. For more information on Clay Testnet, see the Networks page. Dev Unstable \u00b6 Dev Unstable is a Ceramic network used by Ceramic core protocol developers for testing new protocol features and the most recent commits on the develop branch of js-ceramic. It should be considered unstable and highly experimental. Underlying technologies \u00b6 IPFS \u00b6 IPFS is the Interplanetary File System. Simply put, IPFS is a way to address static content using CIDs and to discover this content over a peer-to-peer network of nodes. Ceramic relies on IPFS for storing the commits that make up streams and discovering this data over the network . CID \u00b6 A CID (content identifier) is an immutable identifier for a discrete piece of static content stored on IPFS . CIDs are essentially a hash of the content along with metadata that describes how the content is encoded. Ceramic streams consist of multiple CIDs, encoded using dag-jose (and other formats such as dag-cbor), and linked together using IPLD . IPLD \u00b6 IPLD (Interplanetary Linked Data) is the data structures layer of IPFS . It is used to link multiple CIDs together into higher-level linked-data structures. Ceramic uses IPLD to create the data structures for streams . DagJOSE \u00b6 DagJOSE is a codec for IPLD which stores content in IPFS using IETF's JOSE (JSON object signing and encryption) format. With DagJOSE, each data object actually consists of two separate but linked CIDs . It supports both signed and encrypted objects. JWS is used for signed objects and it encodes the payload as a CID, which means that the actual payload is a separate IPLD object. JWE is used for encrypted objects, and it requires the ciphertext to be a CID in order to not leak the full cleartext. A separate inline CID is used to encode the entire cleartext. For more information refer to the DagJOSE spec . Libp2p \u00b6 Libp2p is the peer-to-peer networking protocol that is used by Ceramic. It is included as part of the IPFS stack. Ceramic relies on libp2p for discovering data over the network and communicating between nodes . Libp2p is also used by other major decentralized platforms such as Ethereum (Eth2) and Polkadot. Ethereum \u00b6 Ethereum is the world's leading public, permissionless smart contract blockchain platform. Ceramic uses Ethereum for generating the timestamps contained within anchor commits .","title":"Glossary"},{"location":"learn/glossary/#glossary-of-terms","text":"This page contains a glossary of terms for Ceramic. Consider this list a work-in-progress; we will continue to update it until it's complete.","title":"Glossary of terms"},{"location":"learn/glossary/#core-concepts","text":"","title":"Core concepts"},{"location":"learn/glossary/#streams","text":"Streams are DAG-based data structures for storing continuous, mutable streams of content on IPFS and tracking state in a completely decentralized, peer-to-peer way. When syncing or loading a stream from the network , you will always get back the current state.","title":"Streams"},{"location":"learn/glossary/#streamid","text":"A StreamID is an immutable identifier for a stream . StreamIDs enable continuous streams of data to be referenced by a persistent identifier instead of by constantly-changing IPFS CIDs .","title":"StreamID"},{"location":"learn/glossary/#streamtypes","text":"StreamTypes are functions used for processing updates to streams . StreamTypes handle everything from defining the data structure of the stream, to what can be stored in its commits , its state transitition function, authentication requirements, and conflict resolution strategy . Every stream must specify a StreamType; and StreamTypes run on Ceramic nodes . Ceramic comes pre-installed with various StreamTypes , or you can code your own.","title":"StreamTypes"},{"location":"learn/glossary/#commits","text":"Commits are individual IPFS records that make up a stream . Streams may contain one or more commits.","title":"Commits"},{"location":"learn/glossary/#genesis-commit","text":"A genesis commit is the first commit in a stream . Genesis commits may be signed by a public key, or unsigned.","title":"Genesis commit"},{"location":"learn/glossary/#signed-commit","text":"Signed commits are commits that update the state of a stream . All signed commits need to be cryptographically signed by a public key.","title":"Signed commit"},{"location":"learn/glossary/#anchor-commit","text":"Anchor commits are commits that contain a blockchain timestamp, providing an immutable record of time and ordering to other commits in the stream , sometimes known as a proof-of-publication .","title":"Anchor commit"},{"location":"learn/glossary/#commitid","text":"A commitID is an immutable identifier for a specific commit in a stream .","title":"CommitID"},{"location":"learn/glossary/#state","text":"State represents the state of a stream at various points in time. When a stream is loaded or queried from the network , the current state is returned.","title":"State"},{"location":"learn/glossary/#tip","text":"A tip is the CID for the most recent commit(s) of a stream .","title":"Tip"},{"location":"learn/glossary/#conflict-resolution-strategy","text":"A conflict resolution strategy is logic defined by a StreamType that describes how the protocol should handle conflicting updates to a stream that uses this StreamType.","title":"Conflict resolution strategy"},{"location":"learn/glossary/#controllers","text":"Controllers are entities allowed to perform updates to a stream , by creating new signed commits . A given stream may have one or more controllers.","title":"Controllers"},{"location":"learn/glossary/#stream-authentication","text":"","title":"Stream authentication"},{"location":"learn/glossary/#authentication","text":"Authentication allows a user to perform protected operations on a stream, such as creating genesis commits , signed commits , or decrypting data. Each StreamType implementation is able to specify its own authentication mechanism as long as the signatures can be resolved/validated by Ceramic, but most StreamTypes use DIDs .","title":"Authentication"},{"location":"learn/glossary/#dids","text":"DIDs is the W3C standard for decentralized identifiers. The DID specification outlines a standard URI scheme for creating a persistent decentralized identifier (DID) for a given subject as well as resolving metadata about that identifier via a DID document . DIDs are used as an authentication mechanism by most StreamTypes .","title":"DIDs"},{"location":"learn/glossary/#did-methods","text":"DID methods are implementations of the DID specification. DID methods must specify a name for the method in the form of a string (see below), a description of where the DID document is stored (or how it is statically generated), and a DID resolver which can return a DID document given a URI that conforms to that particular DID method. There are over 40 DID methods on the W3C's official DID registry. Ceramic can support any DID method if needed, and currently supports the 3ID DID method and the Key DID method . DID URIs look like this: did:<method-name>:<method-specific-identifier>","title":"DID methods"},{"location":"learn/glossary/#did-document","text":"DID documents are documents which contain metadata about a given DID. At a minimum they should contain cryptographic key material used for signature verification and encryption/decryption. They may be mutable where their keys and content can be changed/rotated (i.e. 3ID DID method ) or statically generated where their contents cannot be manually changed (i.e. Key DID method ).","title":"DID document"},{"location":"learn/glossary/#did-resolver","text":"DID resolvers are software libraries responsible for returning a DID document given a DID string. Each DID method has at least one resolver implementation. For all DID methods supported by Ceramic, the corresponding DID resolver must be included in a Ceramic node .","title":"DID resolver"},{"location":"learn/glossary/#did-providers","text":"DID providers are software libraries that allow developers or other programs to create, manage, and use DIDs that conform to a particular DID method . When using Ceramic with streams that require DIDs for authentication , applications either need to integrate a DID provider library, which leaves the responsibility of key management up to the application, or a DID wallet , which is a more user-friendly experience.","title":"DID providers"},{"location":"learn/glossary/#did-wallets","text":"DID wallets are software libraries or end-user applications that wrap DID providers with additional capabilities. 3ID Connect is the most popular DID wallet SDK that allows users create, manage, and use a 3ID DID method with their existing blockchain wallets, and without needing to install any additional software.","title":"DID wallets"},{"location":"learn/glossary/#network","text":"","title":"Network"},{"location":"learn/glossary/#clients","text":"Clients are software libraries that provide developer interfaces to a Ceramic node . Clients are responsible for authenticating users , providing StreamType -specific interfaces for generating genesis commits and signed commits , and providing generic, streamtype-agnostic interfaces for loading or querying streams. A list of Ceramic clients can be found here .","title":"Clients"},{"location":"learn/glossary/#nodes","text":"Nodes are software libraries that provide core protocol functionality for the Ceramic network . Nodes are responsible for processing stream updates (in the form of signed commits from clients ), storing state for the streams that it cares about, responding to queries, networking with other nodes, replicating streams across the network, and sending valid signed commits to an external anchor service for generating anchor commits .","title":"Nodes"},{"location":"learn/glossary/#anchor-service","text":"Anchor services are hosted \"layer-2\" services for Ceramic that generate anchor commits for many different streams in a scalable, low cost manner by batching many different stream transactions into a merkle tree, and including the merkle root into a transaction on a blockchain platform (currently Ethereum ). This eliminates the need for each stream transaction to have its own corresponding blockchain transaction, which would be slower and more expensive.","title":"Anchor service"},{"location":"learn/glossary/#networks","text":"Networks are collections of Ceramic nodes that share specific configurations and communicate over a dedicated libp2p topic. Networks are discrete from one another. Streams that exist on one network are not discoverable on or portable to another. Currently, Ceramic has three primary networks: mainnet , Clay Testnet , and dev unstable .","title":"Networks"},{"location":"learn/glossary/#mainnet","text":"Mainnet is the Ceramic network used for production deployments. For more information on mainnet, see the Networks page.","title":"Mainnet"},{"location":"learn/glossary/#clay-testnet","text":"Clay Testnet is a Ceramic network used by the community for application prototyping, development, and testing purposes. Ceramic core devs also use Clay for testing official protocol release candidates. For more information on Clay Testnet, see the Networks page.","title":"Clay Testnet"},{"location":"learn/glossary/#dev-unstable","text":"Dev Unstable is a Ceramic network used by Ceramic core protocol developers for testing new protocol features and the most recent commits on the develop branch of js-ceramic. It should be considered unstable and highly experimental.","title":"Dev Unstable"},{"location":"learn/glossary/#underlying-technologies","text":"","title":"Underlying technologies"},{"location":"learn/glossary/#ipfs","text":"IPFS is the Interplanetary File System. Simply put, IPFS is a way to address static content using CIDs and to discover this content over a peer-to-peer network of nodes. Ceramic relies on IPFS for storing the commits that make up streams and discovering this data over the network .","title":"IPFS"},{"location":"learn/glossary/#cid","text":"A CID (content identifier) is an immutable identifier for a discrete piece of static content stored on IPFS . CIDs are essentially a hash of the content along with metadata that describes how the content is encoded. Ceramic streams consist of multiple CIDs, encoded using dag-jose (and other formats such as dag-cbor), and linked together using IPLD .","title":"CID"},{"location":"learn/glossary/#ipld","text":"IPLD (Interplanetary Linked Data) is the data structures layer of IPFS . It is used to link multiple CIDs together into higher-level linked-data structures. Ceramic uses IPLD to create the data structures for streams .","title":"IPLD"},{"location":"learn/glossary/#dagjose","text":"DagJOSE is a codec for IPLD which stores content in IPFS using IETF's JOSE (JSON object signing and encryption) format. With DagJOSE, each data object actually consists of two separate but linked CIDs . It supports both signed and encrypted objects. JWS is used for signed objects and it encodes the payload as a CID, which means that the actual payload is a separate IPLD object. JWE is used for encrypted objects, and it requires the ciphertext to be a CID in order to not leak the full cleartext. A separate inline CID is used to encode the entire cleartext. For more information refer to the DagJOSE spec .","title":"DagJOSE"},{"location":"learn/glossary/#libp2p","text":"Libp2p is the peer-to-peer networking protocol that is used by Ceramic. It is included as part of the IPFS stack. Ceramic relies on libp2p for discovering data over the network and communicating between nodes . Libp2p is also used by other major decentralized platforms such as Ethereum (Eth2) and Polkadot.","title":"Libp2p"},{"location":"learn/glossary/#ethereum","text":"Ethereum is the world's leading public, permissionless smart contract blockchain platform. Ceramic uses Ethereum for generating the timestamps contained within anchor commits .","title":"Ethereum"},{"location":"learn/mainnet/","text":"Mainnet is live! \u00b6 After over a year of development, we're excited to announce that the first projects are onboarding to Ceramic Mainnet . Their integrations are currently being tested and their names will be added here once they go live. Mainnet rollout plan \u00b6 To stress-test network stability and performance in production, Ceramic Mainnet is being rolled out in phases. At this time, only projects selected from the waitlist can deploy to Mainnet. This happens in cohorts. As we validate that the network performs favorably under these conditions, we will fully open up Mainnet to the public. Sign up \u00b6 If you want to deploy to mainnet in the near future, sign up for the Mainnet waitlist . While on the waitlist, you can always develop and prototype your integration on the Clay testnet . Demonstrating a fully-functioning integration that is ready for mainnet is a great way to increase your odds of being seleted from the waitlist. If you have questions or need further prioritization, you can join the Discord and let us know.","title":"Mainnet"},{"location":"learn/mainnet/#mainnet-is-live","text":"After over a year of development, we're excited to announce that the first projects are onboarding to Ceramic Mainnet . Their integrations are currently being tested and their names will be added here once they go live.","title":"Mainnet is live!"},{"location":"learn/mainnet/#mainnet-rollout-plan","text":"To stress-test network stability and performance in production, Ceramic Mainnet is being rolled out in phases. At this time, only projects selected from the waitlist can deploy to Mainnet. This happens in cohorts. As we validate that the network performs favorably under these conditions, we will fully open up Mainnet to the public.","title":"Mainnet rollout plan"},{"location":"learn/mainnet/#sign-up","text":"If you want to deploy to mainnet in the near future, sign up for the Mainnet waitlist . While on the waitlist, you can always develop and prototype your integration on the Clay testnet . Demonstrating a fully-functioning integration that is ready for mainnet is a great way to increase your odds of being seleted from the waitlist. If you have questions or need further prioritization, you can join the Discord and let us know.","title":"Sign up"},{"location":"learn/networks/","text":"Networks \u00b6 Networks are collections of Ceramic nodes that share specific configurations and communicate over dedicated libp2p topics. Networks are discrete from one another. Streams that exist on one network are not discoverable on or portable to another. Public networks \u00b6 Ceramic has three public networks that you can use when building applications: Mainnet, Clay Testnet, and Dev Unstable. Mainnet \u00b6 Mainnet is the main public network used for production deployments on Ceramic. Ceramic's mainnet nodes communicate over the dedicated /ceramic/mainnet libp2p topic and use Ethereum's mainnet blockchain ( EIP155:1 ) for generating timestamps used in anchor commits for streams . Mainnet is currently running and anyone can openly query data from streams on mainnet using the community mainnet gateway , but deployments that require writing data to the network are restricted to those projects on the mainnet early launch program (ELP) waitlist. If you want to write data to mainnet, sign up for ELP here . Over time, we will fully open mainnet to all applications. Clay Testnet \u00b6 Clay Testnet is a public Ceramic network used by the community for application prototyping, development, and testing purposes. Ceramic core devs also use Clay for testing official protocol release candidates. While we aim to maintain a high level of quality on the Clay testnet that mirrors the expectations of Mainnet as closely as possible, ultimately the reliability, performance, and stability guarantees of the Clay network are lower than that of Mainnet. Because of this, the Clay network should not be used for applications in production . Clay nodes communicate over the dedicated /ceramic/testnet-clay libp2p topic and use Ethereum's Rinkeby and Ropsten testnet blockchains for generating timestamps used in anchor commits for streams . Clay is openly available for anyone to use now. Dev Unstable \u00b6 Dev Unstable is a public Ceramic network used by Ceramic core protocol developers for testing new protocol features and the most recent commits on the develop branch of js-ceramic . It should be considered unstable and highly experimental; only use this network if you want to test the most cutting edge features, but expect issues. Dev Unstable nodes communicate over the dedicated /ceramic/dev-unstable libp2p topic and use Ethereum's Rinkeby and Ropsten testnet blockchains for generating timestamps used in anchor commits for streams . Private networks \u00b6 You can also prototype applications on Ceramic by running the protocol in a local environment completely disconnected from other public nodes. Local \u00b6 Local is a private test network used for the local development of Ceramic applications. Nodes connected to the same local network communicate over a randomly-generated libp2p topic /ceramic/local-$(randomNumber) and use a local Ethereum blockchain provided by Truffle's Ganache for generating timestamps used in anchor commits for streams .","title":"Networks"},{"location":"learn/networks/#networks","text":"Networks are collections of Ceramic nodes that share specific configurations and communicate over dedicated libp2p topics. Networks are discrete from one another. Streams that exist on one network are not discoverable on or portable to another.","title":"Networks"},{"location":"learn/networks/#public-networks","text":"Ceramic has three public networks that you can use when building applications: Mainnet, Clay Testnet, and Dev Unstable.","title":"Public networks"},{"location":"learn/networks/#mainnet","text":"Mainnet is the main public network used for production deployments on Ceramic. Ceramic's mainnet nodes communicate over the dedicated /ceramic/mainnet libp2p topic and use Ethereum's mainnet blockchain ( EIP155:1 ) for generating timestamps used in anchor commits for streams . Mainnet is currently running and anyone can openly query data from streams on mainnet using the community mainnet gateway , but deployments that require writing data to the network are restricted to those projects on the mainnet early launch program (ELP) waitlist. If you want to write data to mainnet, sign up for ELP here . Over time, we will fully open mainnet to all applications.","title":"Mainnet"},{"location":"learn/networks/#clay-testnet","text":"Clay Testnet is a public Ceramic network used by the community for application prototyping, development, and testing purposes. Ceramic core devs also use Clay for testing official protocol release candidates. While we aim to maintain a high level of quality on the Clay testnet that mirrors the expectations of Mainnet as closely as possible, ultimately the reliability, performance, and stability guarantees of the Clay network are lower than that of Mainnet. Because of this, the Clay network should not be used for applications in production . Clay nodes communicate over the dedicated /ceramic/testnet-clay libp2p topic and use Ethereum's Rinkeby and Ropsten testnet blockchains for generating timestamps used in anchor commits for streams . Clay is openly available for anyone to use now.","title":"Clay Testnet"},{"location":"learn/networks/#dev-unstable","text":"Dev Unstable is a public Ceramic network used by Ceramic core protocol developers for testing new protocol features and the most recent commits on the develop branch of js-ceramic . It should be considered unstable and highly experimental; only use this network if you want to test the most cutting edge features, but expect issues. Dev Unstable nodes communicate over the dedicated /ceramic/dev-unstable libp2p topic and use Ethereum's Rinkeby and Ropsten testnet blockchains for generating timestamps used in anchor commits for streams .","title":"Dev Unstable"},{"location":"learn/networks/#private-networks","text":"You can also prototype applications on Ceramic by running the protocol in a local environment completely disconnected from other public nodes.","title":"Private networks"},{"location":"learn/networks/#local","text":"Local is a private test network used for the local development of Ceramic applications. Nodes connected to the same local network communicate over a randomly-generated libp2p topic /ceramic/local-$(randomNumber) and use a local Ethereum blockchain provided by Truffle's Ganache for generating timestamps used in anchor commits for streams .","title":"Local"},{"location":"learn/overview/","text":"Overview \u00b6 Ceramic is a public, permissionless, open source protocol that provides computation, state transformations, and consensus for all types of data structures stored on the decentralized web. Ceramic's stream processing enables developers to build secure, trustless, censorship-resistant applications on top of dynamic information without trusted database servers. This overview introduces how: Decentralized content computation gives rise to a new era of open source information Stream processing provides an appropriate framework for dynamic, decentralized content You can use Ceramic to replace your database with a truly decentralized alternative To skip ahead and get started building, try the Playground to demo Ceramic in a browser application, the Quick Start guide to learn the basics using the Ceramic CLI, or follow the Installation page to integrate Ceramic into your project. The internet of open source information \u00b6 At its core, the internet is a collection of applications running on stateful data sources \u2013 from identity systems and user tables to databases and feeds for storing all kinds of content generated by users, services, or machines. Most of the information on today's internet is locked away on application-specific database servers designed to protect data as a proprietary resource. Acting as a trusted middleman, applications make it difficult and opaque for others to access this information by requiring explicit permissions, one-off API integrations, and trust that returned state is correct. This siloed and competitive environment results in more friction for developers and worse experiences for users. Along other dimensions, the web has rapidly evolved into a more open source, composable, and collaborative ecosystem. We can observe this trend in open source software enabled by Git's distributed version control and in open source finance enabled by blockchain's double-spend protection. The same principles of open source have not yet been applied to content. The next wave of transformative innovation will be in applying the same open source principles to the world's information, unlocking a universe of content that can be frictionlessly shared across application or organizational boundaries. Achieving this requires a decentralized computation network designed specifically for content with flexibility, scalability, and composability as first class requirements. Decentralized content computation \u00b6 Open sourcing the content layer for applications requires deploying information to a public, permissionless environment where files can be stored, computation can be performed, state can be tracked, and others can easily access content. Advancements in other Web3 protocols have already achieved success in decentralized file storage. As a universal file system for the decentralized web, IPFS (including IPLD and Libp2p ) provides an extremely flexible content naming and routing system. As a storage disk, durable persistence networks (such as Filecoin , Arweave , and Sia ) ensure that the content represented in IPFS files are persisted and kept available. This stack of Web3 protocols performs well for storing static files, but on its own lacks the computation and state management capacity for more advanced database-like features such as mutability, version control, access control, and programmable logic. These are required to enable developers to build fully-featured decentralized applications. Ceramic enables static files to be composed into higher-order mutable data structures, programmed to behave in any desired manner, and whose resulting state is stored and replicated across a decentralized network of nodes. Ceramic builds upon and extends the IPFS file system and underlying persistence networks, as well as other open standards in the decentralized ecosystem, with a general-purpose decentralized content computation substrate. Due to Ceramic's permissionless design and unified global network, anyone in the world can openly create, discover, query, and build upon existing data without needing to trust a centralized server, integrate one-off APIs, or worry if the state of information being returned is correct. Streams \u00b6 Ceramic's decentralized content computation network is modeled after various stream processing frameworks found in Web2. In these types of systems, events are ingested, processed as they arrive, and the resulting output is applied to a log. When queried and reduced, this log represents the current state of a piece of information. This is an appropriate framework for conceptualizing how dynamic information should be modeled on the decentralized web. Furthermore because the function that processes incoming events on any particular stream can be custom written with logic for any use case, it provides the general-purpose flexibility and extensibility needed to represent the diversity of information that may exist on the web. On Ceramic, each piece of information is represented as an append-only log of commits, called a Stream . Each stream is a DAG stored in IPLD, with an immutable name called a StreamID , and a verifiable state called a StreamState . Streams are similar in concept to Git trees, and each stream can be thought of as its own blockchain, ledger, or event log. StreamTypes \u00b6 Each stream must specify a StreamType , which is the processing logic used by the particular stream. A StreamType is essentially a function that is executed by a Ceramic node upon receipt of a new commit to the stream that governs the stream's state transitions and resulting output. StreamTypes are responsible for enforcing all rules and logic for the stream, such as data structure, content format, authentication or access control, and consensus algorithm. If an update does not conform to the logic specified by the StreamType, the update is disregarded. After applying a valid commit to the stream, the resulting StreamState is broadcast out to the rest of the nodes on the Ceramic Network. Each of the other nodes that are also maintaining this stream will update their StreamState to reflect this new transaction. Ceramic's flexible StreamTypes framework enables developers to deploy any kind of information that conforms to any set of arbitrary rules as a stateful stream of events. Ceramic clients come pre-packaged with a standard set of StreamTypes that cover a wide range of common use cases, making it easy to get started building applications: Tile Document: a StreamType that stores a JSON document, providing similar functionality as a NoSQL document store. Tile Documents are frequently used as a database replacement for identity metadata (profiles, social graphs, reputation scores, linked social accounts), user-generated content (blog posts, social media, etc), indexes of other StreamIDs to form collections and user tables (IDX), DID documents, verifiable claims, and more. Tile Documents rely on DIDs for authentication and all valid updates to a stream must be signed by the DID that controls the stream. CAIP-10 Link: a StreamType that stores a cryptographically verifiable proof that links a blockchain address to a DID. A DID can have an unlimited number of CAIP-10 Links that bind it to many different addresses on many different blockchain networks. CAIP-10 Links also rely on DIDs for authentication, same as the Tile Document. Custom: You can implement your own StreamType and deploy it to your Ceramic node if the pre-packaged StreamTypes are not suitable for your use case. Authentication \u00b6 StreamTypes are able to specify their authentication requirements for how new data is authorized to be added to a particular stream. Different StreamTypes may choose to implement different authentication requirements. One of the most powerful and important authentication mechanisms that Ceramic StreamTypes support is DIDs , the W3C standard for decentralized identifiers. DIDs are used by the default StreamTypes (Tile Documents and CAIP-10 Links). DIDs provide a way to go from a globally-unique, platform-agnostic string identifier to a DID document containing public keys for signature verification and encryption. Ceramic is capable of supporting any DID method implementation. Below, find the DID methods that are currently supported by Ceramic: 3ID DID Method : A DID method that uses Ceramic's Tile Document StreamType to represent a mutable DID document. 3IDs are typically used for end-user accounts. When 3IDs are used in conjunction with IDX and the 3ID Keychain (as is implemented in 3ID Connect ), a 3ID can easily be controlled with any number of blockchain accounts from any L1 or L2 network. This provides a way to unify a user's identity across all other platforms. Key DID Method : A DID method statically generated from any Ed25519 key pair. Key DIDs are typically used for developer accounts. Key DID is lightweight, but the drawback is that its DID document is immutable and has no ability to rotate keys if it is compromised. NFT DID Method (coming soon) : A DID method for any NFT on any blockchain. The DID document is statically generated from on-chain data. The DID associated to the blockchain account of the asset's current owner (using CAIP-10 Links) is the only entity authorized to act on behalf of the NFT DID, authenticate in DID-based systems, and make updates to streams or other data owned by the NFT DID. When owenership of the NFT changes, so does the controller permissions. Safe DID Method (coming soon) : A DID method for a Gnosis Safe smart contract on any blockchain. Typically used for organizations, DAOs, and other multi-sig entities. Ceramic Network \u00b6 The Ceramic Network is a decentralized, worldwide network of nodes running the Ceramic protocol that communicate over a dedicated topic on the Libp2p peer-to-peer networking protocol. Ceramic is able to achieve maximum horizontal scalability, throughput, and performance due to its unique design. Sharded execution environment \u00b6 Unlike traditional blockchain systems where scalability is limited to a single global virtual execution environment (VM) and the state of a single ledger is shared between all nodes, each Ceramic node acts as an individual execution environment for performing computations and validating transactions on streams \u2013 there is no global ledger. This \"built-in\" execution sharding enables the Ceramic Network to scale horizontally to parallelize the processing of an increasing number of simultaneous stream transactions as the number of nodes on the network increases. Such a design is needed to handle the scale of the world's data, which is orders of magnitude greater than the throughput needed on a financial blockchain. Another benefit of this design is that a Ceramic node can perform stream transactions in an offline-first environment and then later sync updates with the rest of the network when it comes back online. Global namespace \u00b6 Since all nodes are part of the same Ceramic Network, every stream on Ceramic exists within a single global namespace where it can be accessed by any other node or referenced by any other stream. This creates a public data web of open source information. Additional node responsibilities \u00b6 In addition to executing stream transactions according to StreamType logic, Ceramic nodes also maintain a few other key responsibilities: StreamState storage: A Ceramic node only persists StreamStates for the streams it cares to keep around, a process called \"pinning.\" Different nodes will maintain StreamStates for different streams, but multiple nodes can maintain the state of a single stream. Commit log storage: A Ceramic node maintains a local copy of all commits to the streams it is pinning. Persistence connectors: Ceramic nodes can optionally utilize an additional durable storage backend for backing up commits for streams it is pinning. This can be any of the persistence networks mentioned above, including Filecoin, Arweave, Sia, etc. (coming soon). Query responses: Ceramic nodes respond to stream queries from clients. If the node has the stream pinned it will return the response; if not, it will ask the rest of the network for the stream over libp2p and then return the response. Broadcasting transactions: When a Ceramic node successfully performs a transaction on a stream, it broadcasts this transaction out the rest of the network over libp2p so other nodes also pinning this stream can update their StreamState to reflect this new transaction. Clients \u00b6 Clients provide standard interfaces for performing transactions and queries on streams, and are installed into applications. Clients are also responsible for authenticating users and signing transactions. Currently there are three clients for Ceramic. Additional client implementations can easily be developed in other programming languages: JS HTTP client: A lightweight JavaScript client which connects to a remote Ceramic node over HTTP. The JS HTTP client is recommended for application developers. JS Core client: A JavaScript client which also includes a full Ceramic node. The JS Core client is for those who want the maximum decentralization of running the full Ceramic protocol directly in a browser application. CLI: A command line interface for interacting with a Ceramic node. Getting started \u00b6 Try Ceramic \u00b6 To experience how Ceramic works in a browser application, try the Playground app. Installation \u00b6 Getting started with Ceramic is simple. Visit the Quick Start guide to learn the basics using the Ceramic CLI or follow the Installation page to integrate Ceramic into your project. Tools and services \u00b6 In addition to various standards referenced throughout this document, the Ceramic community has already begun delevoping many different open source protocols, tools, and services that simplify the experience of developing on Ceramic. Here are a few notable examples: 3ID Connect: A authentication SDK for browser-based applications that allows your users to transact with Ceramic using their blockchain wallet. IDX: A protocol for decentralized identity that allows a DID to aggregate an index of all their data from across all apps in one place. IDX enables user-centric data storage, discovery, and interoperability. It is effectively a decentralized, cross-platform user table. IDX can reference all data source types, including Ceramic streams and other peer-to-peer databases and files. IdentityLink: A service that issues verifiable claims which prove a DID owns various other Web2 social accounts such as Twitter, Github, Discord, Discourse, Telegram, Instagram, etc. Once issued, claims are stored in the DID's IDX. Documint: A browser-based IDE for creating and editing streams. Tiles: An explorer for the Ceramic Network.","title":"Overview"},{"location":"learn/overview/#overview","text":"Ceramic is a public, permissionless, open source protocol that provides computation, state transformations, and consensus for all types of data structures stored on the decentralized web. Ceramic's stream processing enables developers to build secure, trustless, censorship-resistant applications on top of dynamic information without trusted database servers. This overview introduces how: Decentralized content computation gives rise to a new era of open source information Stream processing provides an appropriate framework for dynamic, decentralized content You can use Ceramic to replace your database with a truly decentralized alternative To skip ahead and get started building, try the Playground to demo Ceramic in a browser application, the Quick Start guide to learn the basics using the Ceramic CLI, or follow the Installation page to integrate Ceramic into your project.","title":"Overview"},{"location":"learn/overview/#the-internet-of-open-source-information","text":"At its core, the internet is a collection of applications running on stateful data sources \u2013 from identity systems and user tables to databases and feeds for storing all kinds of content generated by users, services, or machines. Most of the information on today's internet is locked away on application-specific database servers designed to protect data as a proprietary resource. Acting as a trusted middleman, applications make it difficult and opaque for others to access this information by requiring explicit permissions, one-off API integrations, and trust that returned state is correct. This siloed and competitive environment results in more friction for developers and worse experiences for users. Along other dimensions, the web has rapidly evolved into a more open source, composable, and collaborative ecosystem. We can observe this trend in open source software enabled by Git's distributed version control and in open source finance enabled by blockchain's double-spend protection. The same principles of open source have not yet been applied to content. The next wave of transformative innovation will be in applying the same open source principles to the world's information, unlocking a universe of content that can be frictionlessly shared across application or organizational boundaries. Achieving this requires a decentralized computation network designed specifically for content with flexibility, scalability, and composability as first class requirements.","title":"The internet of open source information"},{"location":"learn/overview/#decentralized-content-computation","text":"Open sourcing the content layer for applications requires deploying information to a public, permissionless environment where files can be stored, computation can be performed, state can be tracked, and others can easily access content. Advancements in other Web3 protocols have already achieved success in decentralized file storage. As a universal file system for the decentralized web, IPFS (including IPLD and Libp2p ) provides an extremely flexible content naming and routing system. As a storage disk, durable persistence networks (such as Filecoin , Arweave , and Sia ) ensure that the content represented in IPFS files are persisted and kept available. This stack of Web3 protocols performs well for storing static files, but on its own lacks the computation and state management capacity for more advanced database-like features such as mutability, version control, access control, and programmable logic. These are required to enable developers to build fully-featured decentralized applications. Ceramic enables static files to be composed into higher-order mutable data structures, programmed to behave in any desired manner, and whose resulting state is stored and replicated across a decentralized network of nodes. Ceramic builds upon and extends the IPFS file system and underlying persistence networks, as well as other open standards in the decentralized ecosystem, with a general-purpose decentralized content computation substrate. Due to Ceramic's permissionless design and unified global network, anyone in the world can openly create, discover, query, and build upon existing data without needing to trust a centralized server, integrate one-off APIs, or worry if the state of information being returned is correct.","title":"Decentralized content computation"},{"location":"learn/overview/#streams","text":"Ceramic's decentralized content computation network is modeled after various stream processing frameworks found in Web2. In these types of systems, events are ingested, processed as they arrive, and the resulting output is applied to a log. When queried and reduced, this log represents the current state of a piece of information. This is an appropriate framework for conceptualizing how dynamic information should be modeled on the decentralized web. Furthermore because the function that processes incoming events on any particular stream can be custom written with logic for any use case, it provides the general-purpose flexibility and extensibility needed to represent the diversity of information that may exist on the web. On Ceramic, each piece of information is represented as an append-only log of commits, called a Stream . Each stream is a DAG stored in IPLD, with an immutable name called a StreamID , and a verifiable state called a StreamState . Streams are similar in concept to Git trees, and each stream can be thought of as its own blockchain, ledger, or event log.","title":"Streams"},{"location":"learn/overview/#streamtypes","text":"Each stream must specify a StreamType , which is the processing logic used by the particular stream. A StreamType is essentially a function that is executed by a Ceramic node upon receipt of a new commit to the stream that governs the stream's state transitions and resulting output. StreamTypes are responsible for enforcing all rules and logic for the stream, such as data structure, content format, authentication or access control, and consensus algorithm. If an update does not conform to the logic specified by the StreamType, the update is disregarded. After applying a valid commit to the stream, the resulting StreamState is broadcast out to the rest of the nodes on the Ceramic Network. Each of the other nodes that are also maintaining this stream will update their StreamState to reflect this new transaction. Ceramic's flexible StreamTypes framework enables developers to deploy any kind of information that conforms to any set of arbitrary rules as a stateful stream of events. Ceramic clients come pre-packaged with a standard set of StreamTypes that cover a wide range of common use cases, making it easy to get started building applications: Tile Document: a StreamType that stores a JSON document, providing similar functionality as a NoSQL document store. Tile Documents are frequently used as a database replacement for identity metadata (profiles, social graphs, reputation scores, linked social accounts), user-generated content (blog posts, social media, etc), indexes of other StreamIDs to form collections and user tables (IDX), DID documents, verifiable claims, and more. Tile Documents rely on DIDs for authentication and all valid updates to a stream must be signed by the DID that controls the stream. CAIP-10 Link: a StreamType that stores a cryptographically verifiable proof that links a blockchain address to a DID. A DID can have an unlimited number of CAIP-10 Links that bind it to many different addresses on many different blockchain networks. CAIP-10 Links also rely on DIDs for authentication, same as the Tile Document. Custom: You can implement your own StreamType and deploy it to your Ceramic node if the pre-packaged StreamTypes are not suitable for your use case.","title":"StreamTypes"},{"location":"learn/overview/#authentication","text":"StreamTypes are able to specify their authentication requirements for how new data is authorized to be added to a particular stream. Different StreamTypes may choose to implement different authentication requirements. One of the most powerful and important authentication mechanisms that Ceramic StreamTypes support is DIDs , the W3C standard for decentralized identifiers. DIDs are used by the default StreamTypes (Tile Documents and CAIP-10 Links). DIDs provide a way to go from a globally-unique, platform-agnostic string identifier to a DID document containing public keys for signature verification and encryption. Ceramic is capable of supporting any DID method implementation. Below, find the DID methods that are currently supported by Ceramic: 3ID DID Method : A DID method that uses Ceramic's Tile Document StreamType to represent a mutable DID document. 3IDs are typically used for end-user accounts. When 3IDs are used in conjunction with IDX and the 3ID Keychain (as is implemented in 3ID Connect ), a 3ID can easily be controlled with any number of blockchain accounts from any L1 or L2 network. This provides a way to unify a user's identity across all other platforms. Key DID Method : A DID method statically generated from any Ed25519 key pair. Key DIDs are typically used for developer accounts. Key DID is lightweight, but the drawback is that its DID document is immutable and has no ability to rotate keys if it is compromised. NFT DID Method (coming soon) : A DID method for any NFT on any blockchain. The DID document is statically generated from on-chain data. The DID associated to the blockchain account of the asset's current owner (using CAIP-10 Links) is the only entity authorized to act on behalf of the NFT DID, authenticate in DID-based systems, and make updates to streams or other data owned by the NFT DID. When owenership of the NFT changes, so does the controller permissions. Safe DID Method (coming soon) : A DID method for a Gnosis Safe smart contract on any blockchain. Typically used for organizations, DAOs, and other multi-sig entities.","title":"Authentication"},{"location":"learn/overview/#ceramic-network","text":"The Ceramic Network is a decentralized, worldwide network of nodes running the Ceramic protocol that communicate over a dedicated topic on the Libp2p peer-to-peer networking protocol. Ceramic is able to achieve maximum horizontal scalability, throughput, and performance due to its unique design.","title":"Ceramic Network"},{"location":"learn/overview/#sharded-execution-environment","text":"Unlike traditional blockchain systems where scalability is limited to a single global virtual execution environment (VM) and the state of a single ledger is shared between all nodes, each Ceramic node acts as an individual execution environment for performing computations and validating transactions on streams \u2013 there is no global ledger. This \"built-in\" execution sharding enables the Ceramic Network to scale horizontally to parallelize the processing of an increasing number of simultaneous stream transactions as the number of nodes on the network increases. Such a design is needed to handle the scale of the world's data, which is orders of magnitude greater than the throughput needed on a financial blockchain. Another benefit of this design is that a Ceramic node can perform stream transactions in an offline-first environment and then later sync updates with the rest of the network when it comes back online.","title":"Sharded execution environment"},{"location":"learn/overview/#global-namespace","text":"Since all nodes are part of the same Ceramic Network, every stream on Ceramic exists within a single global namespace where it can be accessed by any other node or referenced by any other stream. This creates a public data web of open source information.","title":"Global namespace"},{"location":"learn/overview/#additional-node-responsibilities","text":"In addition to executing stream transactions according to StreamType logic, Ceramic nodes also maintain a few other key responsibilities: StreamState storage: A Ceramic node only persists StreamStates for the streams it cares to keep around, a process called \"pinning.\" Different nodes will maintain StreamStates for different streams, but multiple nodes can maintain the state of a single stream. Commit log storage: A Ceramic node maintains a local copy of all commits to the streams it is pinning. Persistence connectors: Ceramic nodes can optionally utilize an additional durable storage backend for backing up commits for streams it is pinning. This can be any of the persistence networks mentioned above, including Filecoin, Arweave, Sia, etc. (coming soon). Query responses: Ceramic nodes respond to stream queries from clients. If the node has the stream pinned it will return the response; if not, it will ask the rest of the network for the stream over libp2p and then return the response. Broadcasting transactions: When a Ceramic node successfully performs a transaction on a stream, it broadcasts this transaction out the rest of the network over libp2p so other nodes also pinning this stream can update their StreamState to reflect this new transaction.","title":"Additional node responsibilities"},{"location":"learn/overview/#clients","text":"Clients provide standard interfaces for performing transactions and queries on streams, and are installed into applications. Clients are also responsible for authenticating users and signing transactions. Currently there are three clients for Ceramic. Additional client implementations can easily be developed in other programming languages: JS HTTP client: A lightweight JavaScript client which connects to a remote Ceramic node over HTTP. The JS HTTP client is recommended for application developers. JS Core client: A JavaScript client which also includes a full Ceramic node. The JS Core client is for those who want the maximum decentralization of running the full Ceramic protocol directly in a browser application. CLI: A command line interface for interacting with a Ceramic node.","title":"Clients"},{"location":"learn/overview/#getting-started","text":"","title":"Getting started"},{"location":"learn/overview/#try-ceramic","text":"To experience how Ceramic works in a browser application, try the Playground app.","title":"Try Ceramic"},{"location":"learn/overview/#installation","text":"Getting started with Ceramic is simple. Visit the Quick Start guide to learn the basics using the Ceramic CLI or follow the Installation page to integrate Ceramic into your project.","title":"Installation"},{"location":"learn/overview/#tools-and-services","text":"In addition to various standards referenced throughout this document, the Ceramic community has already begun delevoping many different open source protocols, tools, and services that simplify the experience of developing on Ceramic. Here are a few notable examples: 3ID Connect: A authentication SDK for browser-based applications that allows your users to transact with Ceramic using their blockchain wallet. IDX: A protocol for decentralized identity that allows a DID to aggregate an index of all their data from across all apps in one place. IDX enables user-centric data storage, discovery, and interoperability. It is effectively a decentralized, cross-platform user table. IDX can reference all data source types, including Ceramic streams and other peer-to-peer databases and files. IdentityLink: A service that issues verifiable claims which prove a DID owns various other Web2 social accounts such as Twitter, Github, Discord, Discourse, Telegram, Instagram, etc. Once issued, claims are stored in the DID's IDX. Documint: A browser-based IDE for creating and editing streams. Tiles: An explorer for the Ceramic Network.","title":"Tools and services"},{"location":"learn/use-cases/","text":"Use Cases \u00b6 Explore the many ways your project or business can leverage Ceramic's decentralized data streaming platform. Ceramic is a general-purpose protocol, so this list is definitely non-exhaustive; it's meant to serve as a starting point for ideation. The use cases on this list are not mutually exclusive and many Ceramic integrations will make use of more than one. Decentralized identity \u00b6 Build secure applications using decentralized identities and portable, user-controlled data storage. Ceramic is home to IDX which provides a robust, flexible, and standards-based decentralized identity system that can serve as the cornerstone of any Web3 application. Building with IDX allows users to control their identities and data in a manner independent from any single application or platform, while allowing developers to build data-rich applications without the liability of custodying user data on a centralized server or the poor user experience of forcing users to recreate the same data on every application. Identities are based on W3C standards and can be used with wallets from many different blockchains and Web3 platforms. Decentralized identifiers ( DIDs ) Aggregated and cross-chain identities Web3: Connect wallets from any L1 or L2 protocol Web2: Link social accounts from any platform User profiles Social graphs Data storage Reputation systems Decentralized databases \u00b6 Replace your database backend or local storage and store/host all of your content in mutable, decentralized streams. User data and user-generated content User activity and history Application data Application state and other cookie-like content Cross-device local storage Evolutionary files \u00b6 Store editable, version-controlled files, documents, and other media on IPFS that maintains a tamper-proof and auditable history without needing external services to compute state changes, enforce permissions, or keep track of changing CIDs . Also make these files publicly available and discoverable over a global network. Mutable NFT files JSON documents JSON schemas Arbitrary metadata Verifiable credentials Multi-user applications \u00b6 Leverage the unique features and properties of Ceramic to create permissionless social networks where content is decentralized and owned by users instead of platforms. Social media Community platforms Governance forums Decentralized publications \u00b6 Publish and host content on a decentralized, censorship-resistant platform where data can be made globally available, authorship can be verified, links never rot, and each piece of content can be updated by its creator while still maintaining a tamper-proof audit trail of changes. Blogging platforms News media and publications Cross-application data sharing \u00b6 On Ceramic, all data is published to the open web where it's easy to share verifiable information between different organizations and applications in real-time without worrying about correctness or dealing with centralized servers and one-off API integrations. Cross-application data Cross-organizational data Enterprise system of record (SOR) Semantic web \u00b6 Link multiple streams together to form a graph of relationships between verifiable data objects that can each individually evolve without breaking the graph. Remixable content \u00b6 Fork and remix any streams on the network into entirely new creations. No permission needed.","title":"Use cases"},{"location":"learn/use-cases/#use-cases","text":"Explore the many ways your project or business can leverage Ceramic's decentralized data streaming platform. Ceramic is a general-purpose protocol, so this list is definitely non-exhaustive; it's meant to serve as a starting point for ideation. The use cases on this list are not mutually exclusive and many Ceramic integrations will make use of more than one.","title":"Use Cases"},{"location":"learn/use-cases/#decentralized-identity","text":"Build secure applications using decentralized identities and portable, user-controlled data storage. Ceramic is home to IDX which provides a robust, flexible, and standards-based decentralized identity system that can serve as the cornerstone of any Web3 application. Building with IDX allows users to control their identities and data in a manner independent from any single application or platform, while allowing developers to build data-rich applications without the liability of custodying user data on a centralized server or the poor user experience of forcing users to recreate the same data on every application. Identities are based on W3C standards and can be used with wallets from many different blockchains and Web3 platforms. Decentralized identifiers ( DIDs ) Aggregated and cross-chain identities Web3: Connect wallets from any L1 or L2 protocol Web2: Link social accounts from any platform User profiles Social graphs Data storage Reputation systems","title":"Decentralized identity"},{"location":"learn/use-cases/#decentralized-databases","text":"Replace your database backend or local storage and store/host all of your content in mutable, decentralized streams. User data and user-generated content User activity and history Application data Application state and other cookie-like content Cross-device local storage","title":"Decentralized databases"},{"location":"learn/use-cases/#evolutionary-files","text":"Store editable, version-controlled files, documents, and other media on IPFS that maintains a tamper-proof and auditable history without needing external services to compute state changes, enforce permissions, or keep track of changing CIDs . Also make these files publicly available and discoverable over a global network. Mutable NFT files JSON documents JSON schemas Arbitrary metadata Verifiable credentials","title":"Evolutionary files"},{"location":"learn/use-cases/#multi-user-applications","text":"Leverage the unique features and properties of Ceramic to create permissionless social networks where content is decentralized and owned by users instead of platforms. Social media Community platforms Governance forums","title":"Multi-user applications"},{"location":"learn/use-cases/#decentralized-publications","text":"Publish and host content on a decentralized, censorship-resistant platform where data can be made globally available, authorship can be verified, links never rot, and each piece of content can be updated by its creator while still maintaining a tamper-proof audit trail of changes. Blogging platforms News media and publications","title":"Decentralized publications"},{"location":"learn/use-cases/#cross-application-data-sharing","text":"On Ceramic, all data is published to the open web where it's easy to share verifiable information between different organizations and applications in real-time without worrying about correctness or dealing with centralized servers and one-off API integrations. Cross-application data Cross-organizational data Enterprise system of record (SOR)","title":"Cross-application data sharing"},{"location":"learn/use-cases/#semantic-web","text":"Link multiple streams together to form a graph of relationships between verifiable data objects that can each individually evolve without breaking the graph.","title":"Semantic web"},{"location":"learn/use-cases/#remixable-content","text":"Fork and remix any streams on the network into entirely new creations. No permission needed.","title":"Remixable content"},{"location":"learn/welcome/","text":"Ceramic Developers \u00b6 MAINNET NOW LIVE! We're onboarding the first projects to Mainnet from the waitlist. If you want to deploy to mainnet in the near future, sign up for the Mainnet waitlist . While on the waitlist, you can always develop and prototype your integration on the Clay Testnet . Demonstrating a fully-functioning integration that is ready for mainnet is a great way to increase your odds of being seleted from the waitlist. If you have questions or need further prioritization, you can join the Discord and let us know. Ceramic is a decentralized, open source platform for creating, hosting, and sharing streams of data. With Ceramic's permissionless data streaming network, you can store streams of information and ever-changing files directly on the decentralized web \u2013 and share updates with anyone in the world. Whether you want to learn how the Ceramic protocol works, explore standards and tooling, or get started building \u2013 this site has the resources for you. Learn \u00b6 Overview : Learn about Ceramic's decentralized data streaming platform Features : Explore core features and capabilities Use cases : Dive into common use cases Glossary : A glossary of important terms and concepts Explore \u00b6 Explorers : Discover and inspect streams on the Ceramic network Projects : Browse community projects built on Ceramic Samples : Try Ceramic using a demo or sample application Build \u00b6 Quick start : Get up to speed on the basics using the CLI Installation : Install Ceramic in your project Run a node : Set up and run your own Ceramic node Standards and tools \u00b6 StreamTypes : StreamTypes developed by the community IDX : Protocol and SDK for building apps with decentralized identity and user-controlled data storage 3ID Connect : Authentication SDK that allows users to interact with Ceramic using various blockchain wallets Community \u00b6 Join the Discord to ask questions and engage with the community Follow us on Twitter for updates Read the blog for news, announcements, and tutorials Watch the Youtube channel for videos and presentations","title":"Welcome"},{"location":"learn/welcome/#ceramic-developers","text":"MAINNET NOW LIVE! We're onboarding the first projects to Mainnet from the waitlist. If you want to deploy to mainnet in the near future, sign up for the Mainnet waitlist . While on the waitlist, you can always develop and prototype your integration on the Clay Testnet . Demonstrating a fully-functioning integration that is ready for mainnet is a great way to increase your odds of being seleted from the waitlist. If you have questions or need further prioritization, you can join the Discord and let us know. Ceramic is a decentralized, open source platform for creating, hosting, and sharing streams of data. With Ceramic's permissionless data streaming network, you can store streams of information and ever-changing files directly on the decentralized web \u2013 and share updates with anyone in the world. Whether you want to learn how the Ceramic protocol works, explore standards and tooling, or get started building \u2013 this site has the resources for you.","title":"Ceramic Developers"},{"location":"learn/welcome/#learn","text":"Overview : Learn about Ceramic's decentralized data streaming platform Features : Explore core features and capabilities Use cases : Dive into common use cases Glossary : A glossary of important terms and concepts","title":"Learn"},{"location":"learn/welcome/#explore","text":"Explorers : Discover and inspect streams on the Ceramic network Projects : Browse community projects built on Ceramic Samples : Try Ceramic using a demo or sample application","title":"Explore"},{"location":"learn/welcome/#build","text":"Quick start : Get up to speed on the basics using the CLI Installation : Install Ceramic in your project Run a node : Set up and run your own Ceramic node","title":"Build"},{"location":"learn/welcome/#standards-and-tools","text":"StreamTypes : StreamTypes developed by the community IDX : Protocol and SDK for building apps with decentralized identity and user-controlled data storage 3ID Connect : Authentication SDK that allows users to interact with Ceramic using various blockchain wallets","title":"Standards and tools"},{"location":"learn/welcome/#community","text":"Join the Discord to ask questions and engage with the community Follow us on Twitter for updates Read the blog for news, announcements, and tutorials Watch the Youtube channel for videos and presentations","title":"Community"},{"location":"learn/network/anchor-services/","text":"","title":"Anchor services"},{"location":"learn/network/clients/","text":"Network Overview \u00b6 Ceramic is a decentralized network of nodes that run the Ceramic protocol. Clients \u00b6 Clients are software that provide API access to Ceramic nodes. They allow interactions with the Ceramic network. Responsibilities \u00b6 API Interface \u00b6 Authenticate users \u00b6 Sign records \u00b6 Add more \u00b6 Client Implementations \u00b6 HTTP Client JS Client CLI Client Nodes \u00b6 Nodes are software that run the Ceramic protocol and form a peer-to-peer network with other nodes. Networking \u00b6 Network connection \u00b6 Nodes must specify which Ceramic network they are connecting to. This configuration allows the node to mesh with all other nodes connected to the same network. Gossip updates \u00b6 Nodes must specify which Ceramic network they are connecting to. This configuration allows the node to mesh with all other nodes connected to the same network. Query responses \u00b6 Nodes are responsible for responding to queries about any document that it has. If the node has the document in its cache it will respond directly, but if if doesn't have it, it will ask other nodes on the network for it using libp2p. Storage \u00b6 Loading documents \u00b6 Nodes can ask other nodes for a document and it will sync it from the network and load it in memory. This includes the entire document log (contents) and its most recent tip (state). Caching/Pinning documents \u00b6 Ceramic nodes use an instance of IPFS for short-term pinning/caching the documents that they care about. For each document that it cares about, a node will cache its document log and its tip. Nodes cache the Ceramic nodes come prepackaged with an internal IPFS node, but an externally run IPFS node may be used instead. (add something in here about garbage collection?) Persistence coordination \u00b6 Ceramic nodes may optionally specify one or more external service(s) for the long-term storage of documents. If specified, the node is responsible for forwarding document records to this service. Learn more about persistence options. Transactions \u00b6 Authentication (??) \u00b6 Nodes take a DID provider instance and allow that authenticated user to perform transactions. Record validation \u00b6 Nodes receive records (from clients (or anchor services?)) and then validate that these records conform to the rules of the document's specified doctype. Record application \u00b6 Nodes apply only valid records to the document's document log. Invalid or malformed records are discarded. Anchor service coordination \u00b6 After applying a genesis record or signed record to the document log, nodes then send these records to the HTTP endpoint of an anchor service which anchors it in a blockchain. After successfully anchoring the record, the anchor service sends back an anchor record over libp2p which is then applied to the document log by the node. Conflict resolution \u00b6 Should this be its own category, or should this live elsewhere? Anchor Services \u00b6 Responsibilities \u00b6 Blockchain anchoring \u00b6 The primary responsibility of an anchor service is to generate anchor records by committing signed records into a blockchain. All of the responsibilities below are in service of this primary responsibility. Merkle tree construction \u00b6 Constructs a merkle tree of all signed records that eill be simultaneously committed to a blockchain in a single hash, called a merkle root. Anchor metadata \u00b6 Bloom filter, helps with indexing services. Anchor status messages \u00b6 Sends messages to the pubsub room specified for the Ceramic network that the anchor service is servicing. This allows Ceramic nodesLearn more about anchor status messages.","title":"Network Overview"},{"location":"learn/network/clients/#network-overview","text":"Ceramic is a decentralized network of nodes that run the Ceramic protocol.","title":"Network Overview"},{"location":"learn/network/clients/#clients","text":"Clients are software that provide API access to Ceramic nodes. They allow interactions with the Ceramic network.","title":"Clients"},{"location":"learn/network/clients/#responsibilities","text":"","title":"Responsibilities"},{"location":"learn/network/clients/#client-implementations","text":"HTTP Client JS Client CLI Client","title":"Client Implementations"},{"location":"learn/network/clients/#nodes","text":"Nodes are software that run the Ceramic protocol and form a peer-to-peer network with other nodes.","title":"Nodes"},{"location":"learn/network/clients/#networking","text":"","title":"Networking"},{"location":"learn/network/clients/#storage","text":"","title":"Storage"},{"location":"learn/network/clients/#transactions","text":"","title":"Transactions"},{"location":"learn/network/clients/#anchor-services","text":"","title":"Anchor Services"},{"location":"learn/network/clients/#responsibilities_1","text":"","title":"Responsibilities"},{"location":"learn/network/nodes/","text":"","title":"Nodes"},{"location":"reference/http-api/","text":"HTTP API \u00b6 The HTTP API allows you to manually make HTTP requests that create, modify, and query streams on a remote Ceramic node. If you are building an application, you will usually interact with a node using one of the Ceramic clients , however this documentation is useful if: You have a special use case where you directly want to use HTTP requests You want to implement an HTTP client in a new language Gateway mode Not all of the API methods are available if the Ceramic node runs in gateway mode . This option disables writes, which is useful when exposing your node to the internet. Methods disabled in gateway mode will be clearly marked. Streams \u00b6 The stream endpoint is used to create new streams and to load streams from their StreamID or from their genesis content. Get stream state \u00b6 Load the state of a stream given its StreamID. Request GET /api/v0/streams/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response The response body contains the following fields: streamId - the StreamID of the requested stream as string state - the state of the requested stream as StreamState Example \u00b6 Request $ curl http://localhost:7007/api/v0/streams/kjzl6cwe1jw147r7878h32yazawcll6bxe5v92348cxitif6cota91qp68grbhm Response { \"streamId\" : \"kjzl6cwe1jw147r7878h32yazawcll6bxe5v92348cxitif6cota91qp68grbhm\" , \"state\" : { \"type\" : 0 , \"content\" : { \"Ceramic\" : \"pottery\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [{ \"cid\" : \"bagcqceramof2xi7kh6qblirzkbc7yulcjcticlcob6uvdrx3bexgks37ilva\" , \"type\" : 0 }] , \"anchorScheduledFor\" : \"12/15/2020, 2:45:00 PM\" } } Create stream \u00b6 Disabled in gateway mode Create a new stream, or load a stream from its genesis content. The genesis content may be signed (a DagJWS for streams of type TileDocument), or unsigned in some cases. Request POST /api/v0/streams Request body fields: \u00b6 type - the type code of the streamtype to use (e.g. 0 for TileDocuments). Type codes for the supported stream types can be found in this table . genesis - the genesis content of the stream (will differ per streamtype) opts - options for the stream creation, CreateOpts (optional) Response The response body contains the following fields: streamId - the StreamID of the requested stream as string state - the state of the requested stream as StreamState Example \u00b6 This example creates a TileDocument from an unsigned genesis commit. Note that if the content is defined for a TileDocument genesis commit, it needs to be signed. Request $ curl http://localhost:7007/api/v0/streams -X POST -d '{ \"type\": 0, \"genesis\": { \"header\": { \"family\": \"test\", \"controllers\": [\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"] } } }' -H \"Content-Type: application/json\" Response { \"streamId\" : \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" , \"state\" : { \"type\" : 0 , \"content\" : {} , \"metadata\" : { \"family\" : \"test\" , \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 0 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bafyreihtdxfb6cpcvomm2c2elm3re2onqaix6frq4nbg45eaqszh5mifre\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/15/2020, 3:00:00 PM\" } } Multiqueries \u00b6 The multiqueries endpoint enables querying multiple streams at once, as well as querying streams which are linked. Query multiple streams \u00b6 This endpoint allows you to query multiple StreamIDs. Along with each StreamID an array of paths can be passed. If any of the paths within the stream structure contains a Ceramic StreamID url ( ceramic://<StreamID> ), this linked stream will also be returned as part of the response. Request POST /api/v0/multiqueries Request body fields: \u00b6 queries - an array of MultiQuery objects Response The response body contains a map from StreamID strings to StreamState objects. Example \u00b6 First let's create three streams to query using the ceramic cli: Request1 $ ceramic create tile --content '{ \"Document\": \"A\" }' Response1 StreamID ( kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc ) { \"Document\" : \"A\" } Request2 $ ceramic create tile --content '{ \"Document\": \"B\" }' Response2 StreamID ( kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0 ) { \"Document\" : \"B\" } Request3 $ ceramic create tile --content '{ \"Document\": \"C\", \"link\": \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" }' Response3 StreamID ( kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl ) { \"link\" : \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" , \"Document\" : \"C\" } Now let's query them though the multiqueries endpoint: Request $ curl http://localhost:7007/api/v0/multiqueries -X POST -d '{ \"queries\": [{ \"streamId\": \"kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl\", \"paths\": [\"link\"] }, { \"streamId\": \"kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0\", \"paths\": [] }] }' -H \"Content-Type: application/json\" Response { \"kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl\" : { \"type\" : 0 , \"content\" : { \"link\" : \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" , \"Document\" : \"C\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera5nx45nccxvjjyxsq3so5po77kpqzbfsydy6yflnkt6p5tnjvhbkq\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:45:00 PM\" } , \"kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" : { \"type\" : 0 , \"content\" : { \"Document\" : \"A\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcerawq5h7otlkdwuai7vhogqhs2aeaauwbu2aqclrh4iyu5h54qqogma\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:45:00 PM\" } , \"kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0\" : { \"type\" : 0 , \"content\" : { \"Document\" : \"B\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqceranecdjzw4xheudgkr2amjkntpktci2xv44d7v4hbft3ndpptid6ka\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:45:00 PM\" } } Commits \u00b6 The commits endpoint provides lower level access to the data structure of a Ceramic stream. It is also the enpoint that is used in order to update a stream, by adding a new commit. Get all stream commits \u00b6 By calling GET on the commits endpoint along with a StreamID gives you access to all of the commits of the given stream. This is useful if you want to inspect the stream history, or apply all of the commits to a Ceramic node that is not connected to the network. Request GET /api/v0/commits/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response streamId - the StreamID of the requested stream, string commits - an array of commit objects Example \u00b6 Request $ curl http://localhost:7007/api/v0/commits/kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv Response { \"streamId\" : \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\" , \"commits\" : [ { \"cid\" : \"bagcqcera2faj5vik2giftqxftbngfndkci7x4z5vp3psrf4flcptgkz5xztq\" , \"value\" : { \"jws\" : { \"payload\" : \"AXESIAsUBpZMnue1yQ0BgXsjOFyN0cHq6AgspXnI7qGB54ux\" , \"signatures\" : [ { \"signature\" : \"16tBnfkXQU0yo-RZvfjWhm7pP-hIxJ5m-FIMHlCrRkpjbleoEcaC80Xt7qs_WZOlOCexznjow9aX4aZe51cYCQ\" , \"protected\" : \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\" } ] , \"link\" : \"bafyreialcqdjmte64624sdibqf5sgoc4rxi4d2xibawkk6oi52qydz4lwe\" } , \"linkedBlock\" : \"o2RkYXRhoWV0aXRsZXFNeSBmaXJzdCBEb2N1bWVudGZoZWFkZXKiZnNjaGVtYfZrY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SGZ1bmlxdWVwenh0b1A5blphdVgxcEE0OQ\" } } , { \"cid\" : \"bagcqcera3fkje7je4lvctkam4fvi675avtcuqgrv7dn6aoqljd5lebpl7rfq\" , \"value\" : { \"jws\" : { \"payload\" : \"AXESINm6lI30m3j5H2ausx-ulXj-L9CmFlOTZBZvJ2O734Zt\" , \"signatures\" : [ { \"signature\" : \"zsLJbBSU5xZTQkYlXwEH9xj_t_8frvSFCYs0SlVMPXOnw8zOJOsKnJDQlUOvPJxjt8Bdc_7xoBdmcRG1J1tpCw\" , \"protected\" : \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\" } ] , \"link\" : \"bafyreigzxkki35e3pd4r6zvowmp25fly7yx5bjqwkojwiftpe5r3xx4gnu\" } , \"linkedBlock\" : \"pGJpZNgqWCYAAYUBEiDRQJ7VCtGQWcLlmFpitGoSP35ntX7fKJeFWJ8zKz2+Z2RkYXRhgaNib3BjYWRkZHBhdGhlL21vcmVldmFsdWUY6mRwcmV22CpYJgABhQESINFAntUK0ZBZwuWYWmK0ahI/fme1ft8ol4VYnzMrPb5nZmhlYWRlcqFrY29udHJvbGxlcnOA\" } } ] } Apply a commit to stream \u00b6 Disabled in gateway mode In order to modify a stream we apply a commit to its log. This commit usually contains a signature over a json-patch diff describing a modification to the stream contents. The commit also needs to contain pointers to the previous commit and other metadata. You can read more about this in the Ceramic Specification . Different stream types may have different formats for their commits. If you want to see an example implementation for how to construct a commit you can have a look at the implementation of the TileDocument. Request POST /api/v0/commits Request body fields: \u00b6 streamId - the StreamID of the stream to apply the commit to, string commit - the content of the commit to apply (will differ per streamtype) opts - options for the stream update UpdateOpts (optional) Response streamId - the StreamID of the stream that was modified state - the new state of the stream that was modified, StreamState Example \u00b6 Request $ curl http://localhost:7007/api/v0/commits -X POST -d '{ \"streamId\": \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\", \"commit\": { \"jws\": { \"payload\": \"AXESINm6lI30m3j5H2ausx-ulXj-L9CmFlOTZBZvJ2O734Zt\", \"signatures\": [ { \"signature\": \"zsLJbBSU5xZTQkYlXwEH9xj_t_8frvSFCYs0SlVMPXOnw8zOJOsKnJDQlUOvPJxjt8Bdc_7xoBdmcRG1J1tpCw\", \"protected\": \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\" } ], \"link\": \"bafyreigzxkki35e3pd4r6zvowmp25fly7yx5bjqwkojwiftpe5r3xx4gnu\" }, \"linkedBlock\": \"pGJpZNgqWCYAAYUBEiDRQJ7VCtGQWcLlmFpitGoSP35ntX7fKJeFWJ8zKz2+Z2RkYXRhgaNib3BjYWRkZHBhdGhlL21vcmVldmFsdWUY6mRwcmV22CpYJgABhQESINFAntUK0ZBZwuWYWmK0ahI/fme1ft8ol4VYnzMrPb5nZmhlYWRlcqFrY29udHJvbGxlcnOA\" } }' -H \"Content-Type: application/json\" Response { \"streamId\" : \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\" , \"state\" : { \"type\" : 0 , \"content\" : { \"title\" : \"My first Document\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera2faj5vik2giftqxftbngfndkci7x4z5vp3psrf4flcptgkz5xztq\" , \"type\" : 0 } , { \"cid\" : \"bagcqcera3fkje7je4lvctkam4fvi675avtcuqgrv7dn6aoqljd5lebpl7rfq\" , \"type\" : 1 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:15:00 PM\" , \"next\" : { \"content\" : { \"title\" : \"My first Document\" , \"more\" : 234 } , \"metadata\" : { \"schema\" : null, \"controllers\" : [] } } } } Pins \u00b6 The pins api endpoint can be used to manipulate the pinset. The pinset is all of the streams that a node maintains the state of. Any stream opened by the node that is not pinned will eventually be garbage collected from the node. Add to pinset \u00b6 Disabled in gateway mode This method adds the stream with the given StreamID to the pinset. Request POST /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response If the operation was sucessful the response will be a 200 OK. streamId - the StreamID of the stream which was pinned, string Example \u00b6 Request $ curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl -X POST Response { \"streamId\" : \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" } Remove from pinset \u00b6 Disabled in gateway mode This method removes the stream with the given StreamID from the pinset. Request DELETE /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response If the operation was sucessful the response will be a 200 OK. streamId - the StreamID of the stream which was unpinned, string Example \u00b6 Request $ curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl -X DELETE Response { \"streamId\" : \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" } List streams in pinset \u00b6 Calling this method allows you to list all of the streams that are in the pinset on this node. Request GET /api/v0/pins Response pinnedStreamIds - an array of StreamID strings that are in the pinset Example \u00b6 Request $ curl http://localhost:7007/api/v0/pins Response { \"pinnedStreamIds\" : [ \"k2t6wyfsu4pfwqaju0w9nmi53zo6f5bcier7vc951x4b9rydv6t8q4pvzd5w3l\" , \"k2t6wyfsu4pfxon8reod8xcyka9bujeg7acpz8hgh0jsyc7p2b334izdyzsdp7\" , \"k2t6wyfsu4pfxqseec01fnqywmn8l93p4g2chzyx3sod3hpyovurye9hskcegs\" , \"k2t6wyfsu4pfya9y0ega1vnokf0g5qaus69basy52oxg50y3l35vm9rqbb88t3\" ] } Confirm stream in pinset \u00b6 This method is used to check if a particular stream is in the pinset. Request GET /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response pinnedStreamIds - an array containing the specified StreamID string if that stream is pinned, or an empty array if that stream is not pinned Example \u00b6 Request $ curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl Response { \"pinnedStreamIds\" : [ \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" ] } Node Info \u00b6 The methods under the /node path provides more information about this particular node. Supported blockchains for anchoring \u00b6 Get all of the CAIP-2 chainIds supported by this node. Request GET /api/v0/node/chains Response The response body contains the following fields: supportedChains - and array with CAIP-2 formatted chainIds Example \u00b6 Request $ curl http://localhost:7007/api/v0/node/chains Response { \"supportedChains\" : [ \"eip155:3\" ] } Health check \u00b6 Check the health of the node and the machine it's running on. Run ceramic daemon -h for more details on how this can be configured. Request GET /api/v0/node/healthcheck Response Either a 200 response with the text Alive! , or a 503 with the text Insufficient resources . Example \u00b6 Request $ curl http://localhost:7007/api/v0/node/healthcheck Response Alive!","title":"HTTP API"},{"location":"reference/http-api/#http-api","text":"The HTTP API allows you to manually make HTTP requests that create, modify, and query streams on a remote Ceramic node. If you are building an application, you will usually interact with a node using one of the Ceramic clients , however this documentation is useful if: You have a special use case where you directly want to use HTTP requests You want to implement an HTTP client in a new language Gateway mode Not all of the API methods are available if the Ceramic node runs in gateway mode . This option disables writes, which is useful when exposing your node to the internet. Methods disabled in gateway mode will be clearly marked.","title":"HTTP API"},{"location":"reference/http-api/#streams","text":"The stream endpoint is used to create new streams and to load streams from their StreamID or from their genesis content.","title":"Streams"},{"location":"reference/http-api/#get-stream-state","text":"Load the state of a stream given its StreamID. Request GET /api/v0/streams/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response The response body contains the following fields: streamId - the StreamID of the requested stream as string state - the state of the requested stream as StreamState","title":"Get stream state"},{"location":"reference/http-api/#create-stream","text":"Disabled in gateway mode Create a new stream, or load a stream from its genesis content. The genesis content may be signed (a DagJWS for streams of type TileDocument), or unsigned in some cases. Request POST /api/v0/streams","title":"Create stream"},{"location":"reference/http-api/#multiqueries","text":"The multiqueries endpoint enables querying multiple streams at once, as well as querying streams which are linked.","title":"Multiqueries"},{"location":"reference/http-api/#query-multiple-streams","text":"This endpoint allows you to query multiple StreamIDs. Along with each StreamID an array of paths can be passed. If any of the paths within the stream structure contains a Ceramic StreamID url ( ceramic://<StreamID> ), this linked stream will also be returned as part of the response. Request POST /api/v0/multiqueries","title":"Query multiple streams"},{"location":"reference/http-api/#commits","text":"The commits endpoint provides lower level access to the data structure of a Ceramic stream. It is also the enpoint that is used in order to update a stream, by adding a new commit.","title":"Commits"},{"location":"reference/http-api/#get-all-stream-commits","text":"By calling GET on the commits endpoint along with a StreamID gives you access to all of the commits of the given stream. This is useful if you want to inspect the stream history, or apply all of the commits to a Ceramic node that is not connected to the network. Request GET /api/v0/commits/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response streamId - the StreamID of the requested stream, string commits - an array of commit objects","title":"Get all stream commits"},{"location":"reference/http-api/#apply-a-commit-to-stream","text":"Disabled in gateway mode In order to modify a stream we apply a commit to its log. This commit usually contains a signature over a json-patch diff describing a modification to the stream contents. The commit also needs to contain pointers to the previous commit and other metadata. You can read more about this in the Ceramic Specification . Different stream types may have different formats for their commits. If you want to see an example implementation for how to construct a commit you can have a look at the implementation of the TileDocument. Request POST /api/v0/commits","title":"Apply a commit to stream"},{"location":"reference/http-api/#pins","text":"The pins api endpoint can be used to manipulate the pinset. The pinset is all of the streams that a node maintains the state of. Any stream opened by the node that is not pinned will eventually be garbage collected from the node.","title":"Pins"},{"location":"reference/http-api/#add-to-pinset","text":"Disabled in gateway mode This method adds the stream with the given StreamID to the pinset. Request POST /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response If the operation was sucessful the response will be a 200 OK. streamId - the StreamID of the stream which was pinned, string","title":"Add to pinset"},{"location":"reference/http-api/#remove-from-pinset","text":"Disabled in gateway mode This method removes the stream with the given StreamID from the pinset. Request DELETE /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response If the operation was sucessful the response will be a 200 OK. streamId - the StreamID of the stream which was unpinned, string","title":"Remove from pinset"},{"location":"reference/http-api/#list-streams-in-pinset","text":"Calling this method allows you to list all of the streams that are in the pinset on this node. Request GET /api/v0/pins Response pinnedStreamIds - an array of StreamID strings that are in the pinset","title":"List streams in pinset"},{"location":"reference/http-api/#confirm-stream-in-pinset","text":"This method is used to check if a particular stream is in the pinset. Request GET /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response pinnedStreamIds - an array containing the specified StreamID string if that stream is pinned, or an empty array if that stream is not pinned","title":"Confirm stream in pinset"},{"location":"reference/http-api/#node-info","text":"The methods under the /node path provides more information about this particular node.","title":"Node Info"},{"location":"reference/http-api/#supported-blockchains-for-anchoring","text":"Get all of the CAIP-2 chainIds supported by this node. Request GET /api/v0/node/chains Response The response body contains the following fields: supportedChains - and array with CAIP-2 formatted chainIds","title":"Supported blockchains for anchoring"},{"location":"reference/http-api/#health-check","text":"Check the health of the node and the machine it's running on. Run ceramic daemon -h for more details on how this can be configured. Request GET /api/v0/node/healthcheck Response Either a 200 response with the text Alive! , or a 503 with the text Insufficient resources .","title":"Health check"},{"location":"reference/javascript/anchor-service/","text":"Anchor Service (CAS) \u00b6 The Ceramic Anchor Service (CAS) is a hosted layer 2 solution for batching many Ceramic transactions into a single blockchain transaction. A vanilla Merkle-DAG-based system has no notion of absolute time. Ceramic employs a blockchain to provide tamper-proof timestamps. Ceramic anchor service combines anchor requests (containing a StreamID and a CommitID ) into a Merkle Tree . Then it pushes a transaction containing root of the composed tree to a blockchain. After a transaction makes its way onto a blockchain, a Ceramic node creates a special anchor commit for every anchored stream. The anchor commit references the blockchain transaction. One could deduce thus state of a stream at particular point in time, based on a block time of the transaction. Ceramic network has few separate networks: dev-unstable , testnet-clay , and mainnet . 3Box Labs hosts an instance of Ceramic Service for each network. dev-unstable and testnet-clay use Ethereum Rinkeby or Ethereum Ropsten for anchoring. Transactions are free here, so the anchor services are freely available. mainnet anchor service on the other hand uses main Ethereum network. For some time the mainnet anchor service is only available to early-launch partners because of DoS concerns. When Ceramic network operates in a fully decentralized way, one could run own mainnet anchor service. For now one should rely on the hosted anchor services only. For more details about the JavaScript CAS implementation, refer to its repo: Ceramic Anchor Service","title":"Anchor Service"},{"location":"reference/javascript/anchor-service/#anchor-service-cas","text":"The Ceramic Anchor Service (CAS) is a hosted layer 2 solution for batching many Ceramic transactions into a single blockchain transaction. A vanilla Merkle-DAG-based system has no notion of absolute time. Ceramic employs a blockchain to provide tamper-proof timestamps. Ceramic anchor service combines anchor requests (containing a StreamID and a CommitID ) into a Merkle Tree . Then it pushes a transaction containing root of the composed tree to a blockchain. After a transaction makes its way onto a blockchain, a Ceramic node creates a special anchor commit for every anchored stream. The anchor commit references the blockchain transaction. One could deduce thus state of a stream at particular point in time, based on a block time of the transaction. Ceramic network has few separate networks: dev-unstable , testnet-clay , and mainnet . 3Box Labs hosts an instance of Ceramic Service for each network. dev-unstable and testnet-clay use Ethereum Rinkeby or Ethereum Ropsten for anchoring. Transactions are free here, so the anchor services are freely available. mainnet anchor service on the other hand uses main Ethereum network. For some time the mainnet anchor service is only available to early-launch partners because of DoS concerns. When Ceramic network operates in a fully decentralized way, one could run own mainnet anchor service. For now one should rely on the hosted anchor services only. For more details about the JavaScript CAS implementation, refer to its repo: Ceramic Anchor Service","title":"Anchor Service (CAS)"},{"location":"reference/javascript/blockchain/","text":"Add support for a new blockchain \u00b6 This document contains a guide on how to add support for a new blockchain to the Caip10Link StreamType, and to use it for authentication in Ceramic. Ceramic and blockchain accounts \u00b6 Ceramic interacts with blockchain accounts in two ways: authentication and linking . Authentication \u00b6 3ID Connect (using 3id-did-provider ) creates 3id (Ceramic flavour of DID) private keys based on an externally-provided entropy. It could be provided by a blockchain account by merely signing a well-known message. From a user's standpoint, it is authentication into Ceramic through her blockchain account, be it on Ethereum, Filecoin, EOS, Cosmos or something else. Same signature (=same entropy) generates same Ceramic DID. Linking \u00b6 In addition to generating a DID a user could also link additional blockchain accounts to a Ceramic DID. It establishes a relation blockchain account \u2192 DID that allows one to discover a DID (and associated data like a social profile and data) based on just a blockchain account. Additionally, a link serves as a proof-of-ownership by DID over the blockchain account. This is useful for dApp personalization and UX: one sees familiar names instead of 0xgibberish . Below one additional process is mentioned: validation. It checks if proof-of-ownership in the link is formally correct, i.e., a well-known payload is really signed by the account that is declared in the link. Adding a new blockchain \u00b6 To add a new blockchain to Ceramic one has to implement both linking and validation. We use CAIP-10 to represent accounts in a blockchain agnostic way. If the blockchain you want to add isn't already part of the CAIP standards you should make sure to add it there. Linking \u00b6 To add a new blockchain, one has to implement a new class implementing AuthProvider , put it into the @ceramicnetwork/blockchain-utils-linking package and export it. The auth provider sits between 3id-connect (or 3ID DID Provider) and your blockchain account provider. In case of Ethereum, it might be MetaMask. It is responsible mainly for: authentication ( #authenticate ): provide deterministic entropy creating link ( #createLink ): create a LinkProof object which associates the specified AccountID with a DID The auth provider is expected to know which blockchain account it currently serves. It reports it via #accountId . To reuse the same internal settings, e.g. a connection to a blockchain provider, but with a different account, the auth provider should have a #withAddress method. Let's look at each method required to be implemented by the AuthProvider interface: authenticate() \u00b6 The authenticate function allows a blockchain account to be added as an authentication method (authMethod) to a 3ID. This means using your blockchain account you will always be able to access that 3ID and derive its 3ID Keychain for use, for example in 3ID Connect. Parameters \u00b6 message : string, can be any string AccountID : an instance of a CAIP-10 AccountID provider : specific to your blockchain. This is any standard signer or provider defined for your blockchain. Ideally your ecosystem has a widely-accepted standard interface so that this module can support signing by most accounts. Returns \u00b6 entropy : a hex string representing 32 bytes of entropy, prefixed by 0x The entropy returned by a given AccountID must always be the same. createLink() \u00b6 The createLink function allows a blockchain account to create a verifiable link proof that publicly binds the blockchain account to a given DID. In Ceramic, these these link proofs can be used to create CAIP10Link streams which allow anyone to look up the DID linked to your blockchain account, and then resolve any other public info linked to your DID. The StreamIDs of your CAIP10Links can be stored in the IDX Crypto Accounts records for simple lookup. This function consumes similar arguments as described above. It also consumes the DID string that is being linked. This function is implemented such that when the given AccountID signs a message including the given DID with the given provider, a LinkProof is returned. accountId() \u00b6 The accountId method should return currently used account in the CAIP-10 format. withAccount() \u00b6 The withAccount method should return a new instance of the auth provider that serves a new account. Validation \u00b6 Validation is the counterpart of linking that checks if the signature contained in a LinkProof corresponds to the declared account. To add support for a new blockchain: add a new file named after your blockchain to @ceramicnetwork/blockchain-utils-validation package this file should expose an implementation of the BlockchainHandler interface, having: CAIP-2 namespace for your blockchain a validateLink function that checks if the linking signature was created by the account declared in the LinkProof argument add the newly created BlockchainHandler to the handlers list in index.ts validateLink() \u00b6 The validateLink function validates a given LinkProof. This allows anyone to easily verify LinkProofs and for Ceramic to validate CAIP10Links. The function consumes a LinkProof and returns the LinkProof if valid, otherwise it returns null. Valid typically means that the given signature in the LinkProof is valid over the given message and is created by the given account. Make sure that validateLink can validate links created by AuthProvider#createLink . Currently supported blockchains \u00b6 Below you can see a table which lists supported blockchains and their provider objects. If you add support for a new chain, please make a PR here. Blockchain CAIP-2 namespace Supported providers Notes Cosmos cosmos cosmos provider The Cosmos wallet provider interface is still being standardized and is subject to change. Ethereum eip155 metamask-like ethereum provider Filecoin fil Filecoin Wallet Provider EOS eosio @smontero/eosio-local-provider Polkadot polkadot @polkadot{.js} extention api Doesn't support the authenticate method yet.","title":"Support new Blockchain"},{"location":"reference/javascript/blockchain/#add-support-for-a-new-blockchain","text":"This document contains a guide on how to add support for a new blockchain to the Caip10Link StreamType, and to use it for authentication in Ceramic.","title":"Add support for a new blockchain"},{"location":"reference/javascript/blockchain/#ceramic-and-blockchain-accounts","text":"Ceramic interacts with blockchain accounts in two ways: authentication and linking .","title":"Ceramic and blockchain accounts"},{"location":"reference/javascript/blockchain/#authentication","text":"3ID Connect (using 3id-did-provider ) creates 3id (Ceramic flavour of DID) private keys based on an externally-provided entropy. It could be provided by a blockchain account by merely signing a well-known message. From a user's standpoint, it is authentication into Ceramic through her blockchain account, be it on Ethereum, Filecoin, EOS, Cosmos or something else. Same signature (=same entropy) generates same Ceramic DID.","title":"Authentication"},{"location":"reference/javascript/blockchain/#linking","text":"In addition to generating a DID a user could also link additional blockchain accounts to a Ceramic DID. It establishes a relation blockchain account \u2192 DID that allows one to discover a DID (and associated data like a social profile and data) based on just a blockchain account. Additionally, a link serves as a proof-of-ownership by DID over the blockchain account. This is useful for dApp personalization and UX: one sees familiar names instead of 0xgibberish . Below one additional process is mentioned: validation. It checks if proof-of-ownership in the link is formally correct, i.e., a well-known payload is really signed by the account that is declared in the link.","title":"Linking"},{"location":"reference/javascript/blockchain/#adding-a-new-blockchain","text":"To add a new blockchain to Ceramic one has to implement both linking and validation. We use CAIP-10 to represent accounts in a blockchain agnostic way. If the blockchain you want to add isn't already part of the CAIP standards you should make sure to add it there.","title":"Adding a new blockchain"},{"location":"reference/javascript/blockchain/#linking_1","text":"To add a new blockchain, one has to implement a new class implementing AuthProvider , put it into the @ceramicnetwork/blockchain-utils-linking package and export it. The auth provider sits between 3id-connect (or 3ID DID Provider) and your blockchain account provider. In case of Ethereum, it might be MetaMask. It is responsible mainly for: authentication ( #authenticate ): provide deterministic entropy creating link ( #createLink ): create a LinkProof object which associates the specified AccountID with a DID The auth provider is expected to know which blockchain account it currently serves. It reports it via #accountId . To reuse the same internal settings, e.g. a connection to a blockchain provider, but with a different account, the auth provider should have a #withAddress method. Let's look at each method required to be implemented by the AuthProvider interface:","title":"Linking"},{"location":"reference/javascript/blockchain/#validation","text":"Validation is the counterpart of linking that checks if the signature contained in a LinkProof corresponds to the declared account. To add support for a new blockchain: add a new file named after your blockchain to @ceramicnetwork/blockchain-utils-validation package this file should expose an implementation of the BlockchainHandler interface, having: CAIP-2 namespace for your blockchain a validateLink function that checks if the linking signature was created by the account declared in the LinkProof argument add the newly created BlockchainHandler to the handlers list in index.ts","title":"Validation"},{"location":"reference/javascript/blockchain/#currently-supported-blockchains","text":"Below you can see a table which lists supported blockchains and their provider objects. If you add support for a new chain, please make a PR here. Blockchain CAIP-2 namespace Supported providers Notes Cosmos cosmos cosmos provider The Cosmos wallet provider interface is still being standardized and is subject to change. Ethereum eip155 metamask-like ethereum provider Filecoin fil Filecoin Wallet Provider EOS eosio @smontero/eosio-local-provider Polkadot polkadot @polkadot{.js} extention api Doesn't support the authenticate method yet.","title":"Currently supported blockchains"},{"location":"reference/javascript/did-providers/","text":"DID Providers \u00b6 A DID Provider is a library that exposes a json-rpc interface which is consumed by a Ceramic client or other DID compatible software. Usually it is constructed using a seed that the user controls. See the Authentication page for details on how to use DID providers. 3ID DID Provider \u00b6 The 3ID DID Provider allows you to create and manage a 3ID. ceramicstudio/js-3id-did-provider Key DID Provider \u00b6 A Key DID provider allows you to create and use a Key DID. Below you can find a reference implementation of the ed25519 Key DID. ceramicnetwork/key-did-provider-ed25519","title":"DID Providers"},{"location":"reference/javascript/did-providers/#did-providers","text":"A DID Provider is a library that exposes a json-rpc interface which is consumed by a Ceramic client or other DID compatible software. Usually it is constructed using a seed that the user controls. See the Authentication page for details on how to use DID providers.","title":"DID Providers"},{"location":"reference/javascript/did-providers/#3id-did-provider","text":"The 3ID DID Provider allows you to create and manage a 3ID. ceramicstudio/js-3id-did-provider","title":"3ID DID Provider"},{"location":"reference/javascript/did-providers/#key-did-provider","text":"A Key DID provider allows you to create and use a Key DID. Below you can find a reference implementation of the ed25519 Key DID. ceramicnetwork/key-did-provider-ed25519","title":"Key DID Provider"},{"location":"reference/javascript/did-resolvers/","text":"DID Resolvers \u00b6 A DID resolver is a small library that takes a DID string and returns a DID Document. Ceramic uses DID resolvers to verify transactions by comparing the signature on the transaction to the controller of the document. For the transaction to be valid, a public key corresponding to the transaction must be present in the DID Document of the DID listed as a controller. Below you can find references for the main did-resolver package as well as plugins for specific DID Methods. DID Resolver \u00b6 The main library needed to start resolving DIDs is the did-resolver package. It is maintained by the Decentralized Identity Foundation (DIF) and can be found at their github: decentralized-identity/did-resolver Plugins \u00b6 3ID DID Resolver \u00b6 The 3ID DID Method is a DID that is implemented on top of Ceramic using the tile doctype. The 3ID DID resolver uses Ceramic to resolve DIDs. ceramicnetwork/3id-did-resolver Key DID Resolver \u00b6 The Key DID Method is the most simple DID method. It simply encodes a public key in the DID string, and when resolved converts this public key into a DID Document. ceramicnetwork/key-did-resolver did:key specification","title":"DID Resolvers"},{"location":"reference/javascript/did-resolvers/#did-resolvers","text":"A DID resolver is a small library that takes a DID string and returns a DID Document. Ceramic uses DID resolvers to verify transactions by comparing the signature on the transaction to the controller of the document. For the transaction to be valid, a public key corresponding to the transaction must be present in the DID Document of the DID listed as a controller. Below you can find references for the main did-resolver package as well as plugins for specific DID Methods.","title":"DID Resolvers"},{"location":"reference/javascript/did-resolvers/#did-resolver","text":"The main library needed to start resolving DIDs is the did-resolver package. It is maintained by the Decentralized Identity Foundation (DIF) and can be found at their github: decentralized-identity/did-resolver","title":"DID Resolver"},{"location":"reference/javascript/did-resolvers/#plugins","text":"","title":"Plugins"},{"location":"reference/javascript/did-resolvers/#3id-did-resolver","text":"The 3ID DID Method is a DID that is implemented on top of Ceramic using the tile doctype. The 3ID DID resolver uses Ceramic to resolve DIDs. ceramicnetwork/3id-did-resolver","title":"3ID DID Resolver"},{"location":"reference/javascript/did-resolvers/#key-did-resolver","text":"The Key DID Method is the most simple DID method. It simply encodes a public key in the DID string, and when resolved converts this public key into a DID Document. ceramicnetwork/key-did-resolver did:key specification","title":"Key DID Resolver"},{"location":"run/deployment-tools/","text":"","title":"Deployment tools"},{"location":"run/nodes/","text":"Hosting a node \u00b6 This guide describes how to spin up and run a hosted Ceramic node in JavaScript that can be used as a remote node by the JS HTTP Client or the CLI . It can also be used to replicate and pin streams from any other nodes to improve data redundancy and availability. Installation \u00b6 This guide requires the use of a console, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may still be able to get it to work. You will need to install the node-pre-gyp package globally. This is required until node-webrtc which IPFS depends on is upgraded . npm install -g node-pre-gyp 1. Install the CLI \u00b6 Open your console and install the CLI. $ npm install -g @ceramicnetwork/cli 2. Start the Ceramic node \u00b6 This starts a Ceramic node with a standard configuration on the Clay Testnet at https://localhost:7007 . Behind the scenes a properly configured IPFS instance is started, then IPFS is used to create an instance of the Ceramic JS Core Client connected to the Clay Testnet . Once Ceramic Core is running, an HTTP server is started that serves the Ceramic HTTP API . $ ceramic daemon 3. Use an external IPFS node \u00b6 By default the JS CLI starts a node with a bundled IPFS instance. If you would like to instead run a separate service for IPFS, use the @ceramicnetwork/ipfs-daemon npm package. 4. Configure a network \u00b6 By default the JS CLI starts a node on the Clay Testnet. If you would like to use a different network, you can specify this using the --network option. Currently, it is only possible to host nodes on the Clay Testnet. We will add the ability to run nodes on Mainnet in the near future. 5. Expose endpoints \u00b6 If you want your node and the streams created on it to be discoverable to the rest of the network, make sure the appropriate ports used by IPFS and the Ceramic HTTP API (by default this is port 7007) are publicly accessible. For example, if you are behind a router you may need to set up port forwarding. 6. Enable peer discovery \u00b6 To enable peer discovery, add your node to the appropriate Ceramic peerlist file by submitting a pull request. This is used as a temporary measure to streamline peer discovery until js-ipfs supports DHT lookups. 7. Gateway mode \u00b6 To setup your node with read-only capabilities, enable gateway mode. Users of this node will only be able to read data from the network, but writes will be disabled. Next steps \u00b6 Congratulations! You have now set up a hosted Ceramic node that is ready to receive HTTP requests from the local environment, the JS HTTP Client , the CLI , or to simply serve as another node to replicate and pin streams.","title":"Hosting a node"},{"location":"run/nodes/#hosting-a-node","text":"This guide describes how to spin up and run a hosted Ceramic node in JavaScript that can be used as a remote node by the JS HTTP Client or the CLI . It can also be used to replicate and pin streams from any other nodes to improve data redundancy and availability.","title":"Hosting a node"},{"location":"run/nodes/#installation","text":"This guide requires the use of a console, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may still be able to get it to work. You will need to install the node-pre-gyp package globally. This is required until node-webrtc which IPFS depends on is upgraded . npm install -g node-pre-gyp","title":"Installation"},{"location":"run/nodes/#1-install-the-cli","text":"Open your console and install the CLI. $ npm install -g @ceramicnetwork/cli","title":"1. Install the CLI"},{"location":"run/nodes/#2-start-the-ceramic-node","text":"This starts a Ceramic node with a standard configuration on the Clay Testnet at https://localhost:7007 . Behind the scenes a properly configured IPFS instance is started, then IPFS is used to create an instance of the Ceramic JS Core Client connected to the Clay Testnet . Once Ceramic Core is running, an HTTP server is started that serves the Ceramic HTTP API . $ ceramic daemon","title":"2. Start the Ceramic node"},{"location":"run/nodes/#3-use-an-external-ipfs-node","text":"By default the JS CLI starts a node with a bundled IPFS instance. If you would like to instead run a separate service for IPFS, use the @ceramicnetwork/ipfs-daemon npm package.","title":"3. Use an external IPFS node"},{"location":"run/nodes/#4-configure-a-network","text":"By default the JS CLI starts a node on the Clay Testnet. If you would like to use a different network, you can specify this using the --network option. Currently, it is only possible to host nodes on the Clay Testnet. We will add the ability to run nodes on Mainnet in the near future.","title":"4. Configure a network"},{"location":"run/nodes/#5-expose-endpoints","text":"If you want your node and the streams created on it to be discoverable to the rest of the network, make sure the appropriate ports used by IPFS and the Ceramic HTTP API (by default this is port 7007) are publicly accessible. For example, if you are behind a router you may need to set up port forwarding.","title":"5. Expose endpoints"},{"location":"run/nodes/#6-enable-peer-discovery","text":"To enable peer discovery, add your node to the appropriate Ceramic peerlist file by submitting a pull request. This is used as a temporary measure to streamline peer discovery until js-ipfs supports DHT lookups.","title":"6. Enable peer discovery"},{"location":"run/nodes/#7-gateway-mode","text":"To setup your node with read-only capabilities, enable gateway mode. Users of this node will only be able to read data from the network, but writes will be disabled.","title":"7. Gateway mode"},{"location":"run/nodes/#next-steps","text":"Congratulations! You have now set up a hosted Ceramic node that is ready to receive HTTP requests from the local environment, the JS HTTP Client , the CLI , or to simply serve as another node to replicate and pin streams.","title":"Next steps"},{"location":"run/running-an-anchor-service/","text":"","title":"Running an anchor service"},{"location":"streamtypes/overview/","text":"StreamTypes \u00b6 Each stream on Ceramic must be created using a specific StreamType . StreamTypes are programmable functions responsible for processing all updates to the stream and enforcing logic such as storage, consensus, and authentication. Different StreamTypes have different APIs for performing writes , and some also have particular methods for performing reads. To perform operations on streams, see the API page for the respective StreamTypes below. Default StreamTypes \u00b6 These StreamTypes are included in every Ceramic client and node implementation by default. Applications can make use of them without any additional work by simply using their APIs. TileDocument \u00b6 TileDocuments are streams that store JSON content and support JSON schema validation. They can serve as JSON document stores for arbitrary application data. Overview | API Caip10Link \u00b6 Caip10Links are streams that store proofs which publicly link a blockchain account to a DID. They serve to link one or more Web3 accounts to a DID. Overview | API Custom StreamTypes \u00b6 It is possible to develop custom StreamTypes for use within your application. We will soon add a guide describing how this works.","title":"Overview"},{"location":"streamtypes/overview/#streamtypes","text":"Each stream on Ceramic must be created using a specific StreamType . StreamTypes are programmable functions responsible for processing all updates to the stream and enforcing logic such as storage, consensus, and authentication. Different StreamTypes have different APIs for performing writes , and some also have particular methods for performing reads. To perform operations on streams, see the API page for the respective StreamTypes below.","title":"StreamTypes"},{"location":"streamtypes/overview/#default-streamtypes","text":"These StreamTypes are included in every Ceramic client and node implementation by default. Applications can make use of them without any additional work by simply using their APIs.","title":"Default StreamTypes"},{"location":"streamtypes/overview/#tiledocument","text":"TileDocuments are streams that store JSON content and support JSON schema validation. They can serve as JSON document stores for arbitrary application data. Overview | API","title":"TileDocument"},{"location":"streamtypes/overview/#caip10link","text":"Caip10Links are streams that store proofs which publicly link a blockchain account to a DID. They serve to link one or more Web3 accounts to a DID. Overview | API","title":"Caip10Link"},{"location":"streamtypes/overview/#custom-streamtypes","text":"It is possible to develop custom StreamTypes for use within your application. We will soon add a guide describing how this works.","title":"Custom StreamTypes"},{"location":"streamtypes/caip-10-link/api/","text":"Caip10Link API \u00b6 This guide demonstrates how to create, update, and query Caip10Links using the JS HTTP Client and JS Core Client . Requirements \u00b6 You need an installed client , authenticated user , and a third-party blockchain provider (i.e. wallet) to perform writes to Caip10Links. If you only wish to query Caip10Links then you only need an installed client. Write API \u00b6 Create new Caip10Link \u00b6 Use the Caip10Link.fromAccount() method to create a new Caip10Link for a given Caip10-formatted blockchain address. The newly created Caip10Link will not have any DID associated with it at first. const link = await Caip10Link . fromAccount ( ceramic , accountId , opts ) In this example we create a new empty Caip10Link for the account 0x054...7cb8 on the Ethereum mainnet blockchain ( eip155:1 ). const accountLink = await Caip10Link . fromAccount ( ceramic , '0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8@eip155:1' , ) Parameters \u00b6 ceramic \u00b6 When creating a Caip10Link, the first parameter is the CeramicAPI used to communicate with the ceramic node and it is always required. It will either be an instance of Ceramic when using the JS Core client or an instance of CeramicClient when using the JS HTTP client. accountId \u00b6 The account ID in Caip10 format of the blockchain account being linked. opts | optional \u00b6 The final argument is an instance of CreateOpts , which are options that control network behaviors performed as part of the operation. They are not included in the link itself. Parameter Required? Value Description Default value anchor optional boolean Request an anchor after creating the link true publish optional boolean Publish the new link to the network true sync optional enum Controls behavior related to syncing the current link state from the network SyncOptions.PREFER_CACHE syncTimeoutSeconds optional number How long to wait to hear about the current state of the link from the network 3 By default Caip10Link.fromAccount() will try to query the network for the current stream state. If you know that this is the first time a Caip10Link has been created for this blockchain address, and you wish to avoid waiting on a response from the network unnecessarily, you can set syncTimeoutSeconds to 0 in the opts argument. Set DID to Caip10Link \u00b6 Use the link.setDid() method to set or update the DID associated with a given Caip10Link. const link = await Caip10Link . fromAccount ( ceramic , accountId , opts ) await link . setDid ( did , authProvider , opts ) In this example we create a Caip10Link for the account 0x054...7cb8 on the Ethereum mainnet blockchain ( eip155:1 ) and then associate it with the DID did:3:k2t6...ydki . import { Caip10Link } from '@ceramicnetwork/stream-caip10-link' import { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking' // First, get an ethereum provider for communicating with the ethereum blockchain. // This example assumes you have an ethereum provider available in `window.ethereum`, provided // by the web browser or a browser extension. const ethProvider = window . ethereum // Next use the ethProvider to make an EthereumAuthProvider which can issue LinkProofs linking // addresses on Ethereum to DIDs. const ethAuthProvider = new EthereumAuthProvider ( ethProvider , '0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8' ) const accountId = await ethAuthProvider . accountId () const accountLink = await Caip10Link . fromAccount ( ceramic , accountId ) await accountLink . setDid ( 'did:3:k2t6wyfsu4pg0t2n4j8ms3s33xsgqjhtto04mvq8w5a2v5xo48idyz38l7ydki' , ethAuthProvider ) Parameters \u00b6 did \u00b6 The DID to associate with the caip10 blockchain account represented by this Caip10Link. authProvider \u00b6 An instance of the AuthProvider interface that can create link proofs for the blockchain network that the Caip10 account lives on. opts | optional \u00b6 The final argument is an instance of UpdateOpts , which are options that control network behaviors performed as part of the operation. Parameter Required? Value Description Default value anchor optional boolean Request an anchor after updating the link true publish optional boolean Publish the update to the network true Read API \u00b6 Load a Caip10Link \u00b6 Use the Caip10Link.fromAccount() method to look up a Caip10Link for a given Caip10 blockchain address. const link = await Caip10Link . fromAccount ( ceramic , accountId , opts ) In this example we load a Caip10Link for the account 0x054...7cb8 on the Ethereum mainnet blockchain ( eip155:1 ). const accountLink = await Caip10Link . fromAccount ( ceramic , '0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8@eip155:1' , ) const linkedDid = accountLink . did The examples for creating a new Caip10Link and loading an existing Caip10Link look the same. Caip10Link.fromAccount will create a new link if one doesn't exist, in which case the returned link will have no linked DID associated with it. If the link already exists, however, then Caip10Link.fromAccount will return the current state of the link, which may include a linked DID if one has been set previously. Parameters \u00b6 The parameters for loading a Caip10Link are the same as those for creating a new Caip10Link .","title":"API"},{"location":"streamtypes/caip-10-link/api/#caip10link-api","text":"This guide demonstrates how to create, update, and query Caip10Links using the JS HTTP Client and JS Core Client .","title":"Caip10Link API"},{"location":"streamtypes/caip-10-link/api/#requirements","text":"You need an installed client , authenticated user , and a third-party blockchain provider (i.e. wallet) to perform writes to Caip10Links. If you only wish to query Caip10Links then you only need an installed client.","title":"Requirements"},{"location":"streamtypes/caip-10-link/api/#write-api","text":"","title":"Write API"},{"location":"streamtypes/caip-10-link/api/#create-new-caip10link","text":"Use the Caip10Link.fromAccount() method to create a new Caip10Link for a given Caip10-formatted blockchain address. The newly created Caip10Link will not have any DID associated with it at first. const link = await Caip10Link . fromAccount ( ceramic , accountId , opts ) In this example we create a new empty Caip10Link for the account 0x054...7cb8 on the Ethereum mainnet blockchain ( eip155:1 ). const accountLink = await Caip10Link . fromAccount ( ceramic , '0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8@eip155:1' , )","title":"Create new Caip10Link"},{"location":"streamtypes/caip-10-link/api/#set-did-to-caip10link","text":"Use the link.setDid() method to set or update the DID associated with a given Caip10Link. const link = await Caip10Link . fromAccount ( ceramic , accountId , opts ) await link . setDid ( did , authProvider , opts ) In this example we create a Caip10Link for the account 0x054...7cb8 on the Ethereum mainnet blockchain ( eip155:1 ) and then associate it with the DID did:3:k2t6...ydki . import { Caip10Link } from '@ceramicnetwork/stream-caip10-link' import { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking' // First, get an ethereum provider for communicating with the ethereum blockchain. // This example assumes you have an ethereum provider available in `window.ethereum`, provided // by the web browser or a browser extension. const ethProvider = window . ethereum // Next use the ethProvider to make an EthereumAuthProvider which can issue LinkProofs linking // addresses on Ethereum to DIDs. const ethAuthProvider = new EthereumAuthProvider ( ethProvider , '0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8' ) const accountId = await ethAuthProvider . accountId () const accountLink = await Caip10Link . fromAccount ( ceramic , accountId ) await accountLink . setDid ( 'did:3:k2t6wyfsu4pg0t2n4j8ms3s33xsgqjhtto04mvq8w5a2v5xo48idyz38l7ydki' , ethAuthProvider )","title":"Set DID to Caip10Link"},{"location":"streamtypes/caip-10-link/api/#read-api","text":"","title":"Read API"},{"location":"streamtypes/caip-10-link/api/#load-a-caip10link","text":"Use the Caip10Link.fromAccount() method to look up a Caip10Link for a given Caip10 blockchain address. const link = await Caip10Link . fromAccount ( ceramic , accountId , opts ) In this example we load a Caip10Link for the account 0x054...7cb8 on the Ethereum mainnet blockchain ( eip155:1 ). const accountLink = await Caip10Link . fromAccount ( ceramic , '0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8@eip155:1' , ) const linkedDid = accountLink . did The examples for creating a new Caip10Link and loading an existing Caip10Link look the same. Caip10Link.fromAccount will create a new link if one doesn't exist, in which case the returned link will have no linked DID associated with it. If the link already exists, however, then Caip10Link.fromAccount will return the current state of the link, which may include a linked DID if one has been set previously.","title":"Load a Caip10Link"},{"location":"streamtypes/caip-10-link/overview/","text":"CAIP-10 Link \u00b6 CAIP-10 Link is a StreamType that stores a cryptographically verifiable proof that links a blockchain address to a DID. Use cases \u00b6 A DID can have an unlimited number of CAIP-10 Links that publicly bind it to many different addresses on many different L1 and L2 blockchain networks. Design \u00b6 Authentication: DIDs Ordering: Anchor records checkpointed into a blockchain (via blockheight) Conflict resolution: Earliest anchor wins (EAW)","title":"Overview"},{"location":"streamtypes/caip-10-link/overview/#caip-10-link","text":"CAIP-10 Link is a StreamType that stores a cryptographically verifiable proof that links a blockchain address to a DID.","title":"CAIP-10 Link"},{"location":"streamtypes/caip-10-link/overview/#use-cases","text":"A DID can have an unlimited number of CAIP-10 Links that publicly bind it to many different addresses on many different L1 and L2 blockchain networks.","title":"Use cases"},{"location":"streamtypes/caip-10-link/overview/#design","text":"Authentication: DIDs Ordering: Anchor records checkpointed into a blockchain (via blockheight) Conflict resolution: Earliest anchor wins (EAW)","title":"Design"},{"location":"streamtypes/tile-document/api/","text":"TileDocument API \u00b6 This guide describes how to create, update, and query TileDocuments using the JS HTTP Client and the Core Client . You can also interact with TileDocuments from the CLI ; see the Quick Start guide for more information. Requirements \u00b6 You need an installed client and an authenticated user to perform writes to TileDocuments. If you only wish to query TileDocuments then you do not need authentication. Write APIs \u00b6 Create a TileDocument \u00b6 Use the TileDocument.create() method to create a new TileDocument. const doc = await TileDocument . create ( ceramic , content , metadata , opts ) In this example we create a TileDocument where we set content , schema , controllers , and family . const doc = await TileDocument . create ( ceramic , { foo : \"bar\" }, { controllers : [ ceramic . did . id ], family : \"doc family\" , schema : schemaDoc . commitId , } ) API reference Parameters \u00b6 ceramic \u00b6 When creating a TileDocument, the first parameter is the CeramicAPI used to communicate with the ceramic node and it is always required. It will either be an instance of Ceramic when using the Core client or an instance of CeramicClient when using the HTTP client. content \u00b6 The content of your TileDocument, in the form of a JSON document. If schema is set in the metadata, then the content must conform to the specified schema. When content is included during document creation, the document's genesis commit will be signed by the authenticated user's DID. When content is omitted (set as null or undefined ), then the genesis commit will not be signed. metadata (optional) \u00b6 Parameter Required? Value Description Notes controllers optional array of strings Defines the DID that is allowed to modify the document. Currently only one controller is supported per document If empty, defaults to currently authenticated DID schema optional string CommitID of a Ceramic TileDocument that contains a JSON schema If set, schema will be enforced on content family optional string Allows you to group similar documents into families Useful for indexing groups of like documents on the network tags optional array of strings Allows you to tag similar documents Useful for indexing groups of like documents on the network deterministic optional boolean If false, allows TileDocuments with the same content and metadata to generate unique StreamIDs If empty, defaults to false API reference Using the deterministic parameter For most use cases you will likely want to leave the deterministic parameter set to false. However for special circumstances, you may want this to be set to true. For example this should be set to true if you would like to enable deterministic queries for your TileDocument. If this is your use case, then it is also important that you set content to null during document creation. Deterministic document queries are based entirely on the document's initial metadata. You can proceed to add content to your document by updating it . API reference opts (optional) \u00b6 The final argument to TileDocument.create is an instance of CreateOpts , which are options that control network behaviors performed as part of the operation. They are not included in the document itself. Parameter Required? Value Description Default value anchor optional boolean Request an anchor after creating the document true publish optional boolean Publish the new document to the network true sync optional enum Controls behavior related to syncing the current document state from the network PREFER_CACHE syncTimeoutSeconds optional number How long to wait to hear about the current state of the document from the network 3 for deterministic documents, 0 otherwise API reference Update a TileDocument \u00b6 Use the doc.update() method to update the content or metadata of an existing TileDocument. const doc = await TileDocument . load ( ceramic , streamId , opts ) await doc . update ( newContent , newMetadata , opts ) In this example we update a TileDocument's content while also giving it a tag. const streamId = 'kjzl6cwe1jw14...' // Replace this with the StreamID of the TileDocument to be updated const doc = await TileDocument . load ( ceramic , streamId ) await doc . update ({ foo : 'baz' }, { tags : [ 'baz' ] }) API reference Parameters \u00b6 content \u00b6 The new content of your document. This fully replaces any existing content in the document. metadata (optional) \u00b6 Only fields that are provided in the metadata arg will be updated. Fields not specified in the metadata arg will be left with their current value. API reference Updating the deterministic parameter Please note that the deterministic parameter can only be set while creating a document. It cannot be updated once the document exists. opts (optional) \u00b6 The final argument to TileDocument.update is an instance of UpdateOpts , which are options that control network behaviors performed as part of the operation. They are not included in the document itself. Parameter Required? Value Description Default value anchor optional boolean Request an anchor after updating the document true publish optional boolean Publish the update to the network true API reference Read APIs \u00b6 Load a TileDocument \u00b6 Use the TileDocument.load() method to load a single document using its StreamID const streamId = 'kjzl6cwe1jw14...' // Replace this with the StreamID of the TileDocument to be loaded const doc = await TileDocument . load ( ceramic , streamId , opts ) API reference Parameters \u00b6 ceramic \u00b6 When loading a TileDocument, the first parameter is the CeramicAPI used to communicate with the Ceramic node and it is always required. It will either be an instance of Ceramic when using the Core client or an instance of CeramicClient when using the HTTP client. streamId \u00b6 The StreamID or CommitID of the TileDocument to be loaded. When providing the document's StreamID, Ceramic will attempt to load the most recent version of the document from the network. If a CommitID is provided instead, Ceramic will load the document with the version of the contents and metadata from the specific commit specified. The returned TileDocument object will also be marked readonly and cannot be used to perform updates. opts (optional) \u00b6 The final argument to TileDocument.load is an instance of LoadOpts , which are options that control network behaviors performed as part of the operation. Parameter Required? Value Description Default value sync optional enum Controls behavior related to syncing the current document state from the network SyncOptions.PREFER_CACHE syncTimeoutSeconds optional number How long to wait to hear about the current state of the document from the network 3 API reference Query a deterministic TileDocument \u00b6 In the create section, we discussed how to create a document with the deterministic parameter set to true. Since this parameter allows us to generate the exact same StreamID if we create two documents with the same initial metadata , it is possible to \"query\" the document using the same TileDocument.create method that we used to initially create it, without needing to know the StreamID before performing the query. Note we are setting the CreateOpts parameters ( anchor and publish ) to false so that we are only loading the document and not publishing any changes to the network. const doc = TileDocument . create ( ceramic , null , { controllers : [ 'did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H' ], family : 'example family' , deterministic : true , }, { anchor : false , publish : false } }) API reference","title":"API"},{"location":"streamtypes/tile-document/api/#tiledocument-api","text":"This guide describes how to create, update, and query TileDocuments using the JS HTTP Client and the Core Client . You can also interact with TileDocuments from the CLI ; see the Quick Start guide for more information.","title":"TileDocument API"},{"location":"streamtypes/tile-document/api/#requirements","text":"You need an installed client and an authenticated user to perform writes to TileDocuments. If you only wish to query TileDocuments then you do not need authentication.","title":"Requirements"},{"location":"streamtypes/tile-document/api/#write-apis","text":"","title":"Write APIs"},{"location":"streamtypes/tile-document/api/#create-a-tiledocument","text":"Use the TileDocument.create() method to create a new TileDocument. const doc = await TileDocument . create ( ceramic , content , metadata , opts ) In this example we create a TileDocument where we set content , schema , controllers , and family . const doc = await TileDocument . create ( ceramic , { foo : \"bar\" }, { controllers : [ ceramic . did . id ], family : \"doc family\" , schema : schemaDoc . commitId , } ) API reference","title":"Create a TileDocument"},{"location":"streamtypes/tile-document/api/#update-a-tiledocument","text":"Use the doc.update() method to update the content or metadata of an existing TileDocument. const doc = await TileDocument . load ( ceramic , streamId , opts ) await doc . update ( newContent , newMetadata , opts ) In this example we update a TileDocument's content while also giving it a tag. const streamId = 'kjzl6cwe1jw14...' // Replace this with the StreamID of the TileDocument to be updated const doc = await TileDocument . load ( ceramic , streamId ) await doc . update ({ foo : 'baz' }, { tags : [ 'baz' ] }) API reference","title":"Update a TileDocument"},{"location":"streamtypes/tile-document/api/#read-apis","text":"","title":"Read APIs"},{"location":"streamtypes/tile-document/api/#load-a-tiledocument","text":"Use the TileDocument.load() method to load a single document using its StreamID const streamId = 'kjzl6cwe1jw14...' // Replace this with the StreamID of the TileDocument to be loaded const doc = await TileDocument . load ( ceramic , streamId , opts ) API reference","title":"Load a TileDocument"},{"location":"streamtypes/tile-document/api/#query-a-deterministic-tiledocument","text":"In the create section, we discussed how to create a document with the deterministic parameter set to true. Since this parameter allows us to generate the exact same StreamID if we create two documents with the same initial metadata , it is possible to \"query\" the document using the same TileDocument.create method that we used to initially create it, without needing to know the StreamID before performing the query. Note we are setting the CreateOpts parameters ( anchor and publish ) to false so that we are only loading the document and not publishing any changes to the network. const doc = TileDocument . create ( ceramic , null , { controllers : [ 'did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H' ], family : 'example family' , deterministic : true , }, { anchor : false , publish : false } }) API reference","title":"Query a deterministic TileDocument"},{"location":"streamtypes/tile-document/overview/","text":"TileDocument \u00b6 TileDocument is a StreamType that stores a mutable JSON document, providing similar functionality as a NoSQL document store. Usage \u00b6 See TileDocument API for instructions on how to create and update TileDocument streams. You can query TileDocuments using Ceramic's standard queries API . Specification \u00b6 See TileDocument StreamType (CIP-8) for the complete specification. Storage \u00b6 TileDocuments are streams used for storing JSON documents. The TileDocument stream is structured as a single log of commits , where each commit only contains the diff from the previous version. Optionally, TileDocuments may specify a JSON schema and all commits must adhere to the schema. Consensus \u00b6 TileDocuments rely on anchor commits for providing immutable timestamps for the genesis commit and subsequent signed commits in the stream. In the case of conflicting versions, the branch with the earliest recorded anchor commit will be respected as the canonical branch. Authentication \u00b6 TileDocuments rely on DIDs for authentication . Only the DID(s) assigned as the controller of the stream are allowed to perform writes. Sample use cases \u00b6 TileDocuments are commonly used for storing: Schemas Identity metadata and information User-generated content (i.e. blog posts, social media, etc) Lists of other streamIDs to form collections (i.e. IDX ) DID Documents (i.e. 3ID DID Method ) Verifiable claims and more","title":"Overview"},{"location":"streamtypes/tile-document/overview/#tiledocument","text":"TileDocument is a StreamType that stores a mutable JSON document, providing similar functionality as a NoSQL document store.","title":"TileDocument"},{"location":"streamtypes/tile-document/overview/#usage","text":"See TileDocument API for instructions on how to create and update TileDocument streams. You can query TileDocuments using Ceramic's standard queries API .","title":"Usage"},{"location":"streamtypes/tile-document/overview/#specification","text":"See TileDocument StreamType (CIP-8) for the complete specification.","title":"Specification"},{"location":"streamtypes/tile-document/overview/#storage","text":"TileDocuments are streams used for storing JSON documents. The TileDocument stream is structured as a single log of commits , where each commit only contains the diff from the previous version. Optionally, TileDocuments may specify a JSON schema and all commits must adhere to the schema.","title":"Storage"},{"location":"streamtypes/tile-document/overview/#consensus","text":"TileDocuments rely on anchor commits for providing immutable timestamps for the genesis commit and subsequent signed commits in the stream. In the case of conflicting versions, the branch with the earliest recorded anchor commit will be respected as the canonical branch.","title":"Consensus"},{"location":"streamtypes/tile-document/overview/#authentication","text":"TileDocuments rely on DIDs for authentication . Only the DID(s) assigned as the controller of the stream are allowed to perform writes.","title":"Authentication"},{"location":"streamtypes/tile-document/overview/#sample-use-cases","text":"TileDocuments are commonly used for storing: Schemas Identity metadata and information User-generated content (i.e. blog posts, social media, etc) Lists of other streamIDs to form collections (i.e. IDX ) DID Documents (i.e. 3ID DID Method ) Verifiable claims and more","title":"Sample use cases"},{"location":"streamtypes/tile-document/schemas/basic-profile/","text":"Basic Profile \u00b6 The basic profile schema is used to create a stream that stores basic profile metadata for a DID. It is typically deployed in a Tile Document StreamType, and is one of the default schemas provided in the IDX identity protocol. See CIP-19 for the complete specification. Schema \u00b6 The basic profile schema defines the format of a stream that contains the properties listed below. Properties not defined in the schema cannot be included in the basic profile, however the schema can always by modifying the CIP. Property Description Value Max Size Required Example name a name string 150 char optional Mary Smith image an image Image sources optional description a short description string 420 char optional This is my cool description. emoji an emoji unicode 2 char optional \ud83d\udd22 background a background image (3:1 ratio) Image sources optional birthDate a date of birth ISO 8601 10 char optional 1990-04-24 url a url string 240 char optional http://ceramic.network gender a gender string 42 char optional female residenceCity a city of residence string 140 char optional Berlin residenceCountry a country of residence ISO 3166-1 alpha-2 2 char optional DE nationalities nationalities array of ISO 3166-1 alpha-2 values 2 char optional CN affiliations affiliations array of strings 240 char optional Ceramic Ecosystem Alliance { \"$schema\" : \"http://json-schema.org/draft-07/schema#\" , \"title\" : \"BasicProfile\" , \"type\" : \"object\" , \"definitions\" : { \"IPFSUrl\" : { \"type\" : \"string\" , \"pattern\" : \"^ipfs://.+\" , \"maxLength\" : 150 }, \"positiveInteger\" : { \"type\" : \"integer\" , \"minimum\" : 1 }, \"imageMetadata\" : { \"type\" : \"object\" , \"properties\" : { \"src\" : { \"$ref\" : \"#/definitions/IPFSUrl\" }, \"mimeType\" : { \"type\" : \"string\" , \"maxLength\" : 50 }, \"width\" : { \"$ref\" : \"#/definitions/positiveInteger\" }, \"height\" : { \"$ref\" : \"#/definitions/positiveInteger\" }, \"size\" : { \"$ref\" : \"#/definitions/positiveInteger\" } }, \"required\" : [ \"src\" , \"mimeType\" , \"width\" , \"height\" ] }, \"imageSources\" : { \"type\" : \"object\" , \"properties\" : { \"original\" : { \"$ref\" : \"#/definitions/imageMetadata\" }, \"alternatives\" : { \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/definitions/imageMetadata\" } } }, \"required\" : [ \"original\" ] } }, \"properties\" : { \"name\" : { \"type\" : \"string\" , \"maxLength\" : 150 }, \"image\" : { \"$ref\" : \"#/definitions/imageSources\" }, \"description\" : { \"type\" : \"string\" , \"maxLength\" : 420 }, \"emoji\" : { \"type\" : \"string\" , \"maxLength\" : 2 }, \"background\" : { \"$ref\" : \"#/definitions/imageSources\" }, \"birthDate\" : { \"type\" : \"string\" , \"format\" : \"date\" }, \"url\" : { \"type\" : \"string\" , \"maxLength\" : 240 }, \"gender\" : { \"type\" : \"string\" , \"maxLength\" : 42 }, \"homeLocation\" : { \"type\" : \"string\" , \"maxLength\" : 140 }, \"residenceCountry\" : { \"type\" : \"string\" , \"pattern\" : \"^[A-Z]{2}$\" }, \"nationalities\" : { \"type\" : \"array\" , \"minItems\" : 1 , \"items\" : { \"type\" : \"string\" , \"pattern\" : \"^[A-Z]{2}$\" , \"maxItems\" : 5 } }, \"affiliations\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" , \"maxLength\" : 240 } } } } Usage \u00b6 There are two primary ways to create basic profile streams. With IDX (recommended) \u00b6 IDX is a protocol and SDK that provides a way for developers to build user-centric applications by organizing information around a DID in an application-agnostic way, allowing them to set and get identity records. At its core, IDX functions like a user-centric, decentralized user table shared by all applications which enables maximal interoperability of information. Basic profile is a default schema provided by IDX. See the IDX documentation for how to install IDX in your project. Without IDX \u00b6 You can create streams that conform to the basic profile schema without using IDX, if desired. However, note that without using IDX it will be difficult for your application or other applications to keep track of the StreamIDs of the basic profiles for each of your users. You will need to do this manually. To create a basic profile without using IDX, manually create a Tile Document stream using a Ceramic client and include the StreamID of the basic profile schema in the stream's metadata: k3y52l7qbv1frxt706gqfzmq6cbqdkptzk8uudaryhlkf6ly9vx21hqu4r6k1jqio Example \u00b6 An example of how to create a basic profile stream with js-ceramic. const profile = await ceramic . createDocument ( 'tile' , { metadata : { schema : \"<record-schema-DocID>\" family : \"<definition-DocID>\" }, content : { name : \"Samantha Smith\" , image : { original : { src : \"ipfs://bafy...\" , mimeType : \"image/png\" , width : 500 , height : 200 } }, description : \"This is my funny description.\" , emoji : \"\ud83d\ude80\" , url : \"http://ceramic.network\" } })","title":"BasicProfile"},{"location":"streamtypes/tile-document/schemas/basic-profile/#basic-profile","text":"The basic profile schema is used to create a stream that stores basic profile metadata for a DID. It is typically deployed in a Tile Document StreamType, and is one of the default schemas provided in the IDX identity protocol. See CIP-19 for the complete specification.","title":"Basic Profile"},{"location":"streamtypes/tile-document/schemas/basic-profile/#schema","text":"The basic profile schema defines the format of a stream that contains the properties listed below. Properties not defined in the schema cannot be included in the basic profile, however the schema can always by modifying the CIP. Property Description Value Max Size Required Example name a name string 150 char optional Mary Smith image an image Image sources optional description a short description string 420 char optional This is my cool description. emoji an emoji unicode 2 char optional \ud83d\udd22 background a background image (3:1 ratio) Image sources optional birthDate a date of birth ISO 8601 10 char optional 1990-04-24 url a url string 240 char optional http://ceramic.network gender a gender string 42 char optional female residenceCity a city of residence string 140 char optional Berlin residenceCountry a country of residence ISO 3166-1 alpha-2 2 char optional DE nationalities nationalities array of ISO 3166-1 alpha-2 values 2 char optional CN affiliations affiliations array of strings 240 char optional Ceramic Ecosystem Alliance { \"$schema\" : \"http://json-schema.org/draft-07/schema#\" , \"title\" : \"BasicProfile\" , \"type\" : \"object\" , \"definitions\" : { \"IPFSUrl\" : { \"type\" : \"string\" , \"pattern\" : \"^ipfs://.+\" , \"maxLength\" : 150 }, \"positiveInteger\" : { \"type\" : \"integer\" , \"minimum\" : 1 }, \"imageMetadata\" : { \"type\" : \"object\" , \"properties\" : { \"src\" : { \"$ref\" : \"#/definitions/IPFSUrl\" }, \"mimeType\" : { \"type\" : \"string\" , \"maxLength\" : 50 }, \"width\" : { \"$ref\" : \"#/definitions/positiveInteger\" }, \"height\" : { \"$ref\" : \"#/definitions/positiveInteger\" }, \"size\" : { \"$ref\" : \"#/definitions/positiveInteger\" } }, \"required\" : [ \"src\" , \"mimeType\" , \"width\" , \"height\" ] }, \"imageSources\" : { \"type\" : \"object\" , \"properties\" : { \"original\" : { \"$ref\" : \"#/definitions/imageMetadata\" }, \"alternatives\" : { \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/definitions/imageMetadata\" } } }, \"required\" : [ \"original\" ] } }, \"properties\" : { \"name\" : { \"type\" : \"string\" , \"maxLength\" : 150 }, \"image\" : { \"$ref\" : \"#/definitions/imageSources\" }, \"description\" : { \"type\" : \"string\" , \"maxLength\" : 420 }, \"emoji\" : { \"type\" : \"string\" , \"maxLength\" : 2 }, \"background\" : { \"$ref\" : \"#/definitions/imageSources\" }, \"birthDate\" : { \"type\" : \"string\" , \"format\" : \"date\" }, \"url\" : { \"type\" : \"string\" , \"maxLength\" : 240 }, \"gender\" : { \"type\" : \"string\" , \"maxLength\" : 42 }, \"homeLocation\" : { \"type\" : \"string\" , \"maxLength\" : 140 }, \"residenceCountry\" : { \"type\" : \"string\" , \"pattern\" : \"^[A-Z]{2}$\" }, \"nationalities\" : { \"type\" : \"array\" , \"minItems\" : 1 , \"items\" : { \"type\" : \"string\" , \"pattern\" : \"^[A-Z]{2}$\" , \"maxItems\" : 5 } }, \"affiliations\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" , \"maxLength\" : 240 } } } }","title":"Schema"},{"location":"streamtypes/tile-document/schemas/basic-profile/#usage","text":"There are two primary ways to create basic profile streams.","title":"Usage"},{"location":"streamtypes/tile-document/schemas/basic-profile/#with-idx-recommended","text":"IDX is a protocol and SDK that provides a way for developers to build user-centric applications by organizing information around a DID in an application-agnostic way, allowing them to set and get identity records. At its core, IDX functions like a user-centric, decentralized user table shared by all applications which enables maximal interoperability of information. Basic profile is a default schema provided by IDX. See the IDX documentation for how to install IDX in your project.","title":"With IDX (recommended)"},{"location":"streamtypes/tile-document/schemas/basic-profile/#without-idx","text":"You can create streams that conform to the basic profile schema without using IDX, if desired. However, note that without using IDX it will be difficult for your application or other applications to keep track of the StreamIDs of the basic profiles for each of your users. You will need to do this manually. To create a basic profile without using IDX, manually create a Tile Document stream using a Ceramic client and include the StreamID of the basic profile schema in the stream's metadata: k3y52l7qbv1frxt706gqfzmq6cbqdkptzk8uudaryhlkf6ly9vx21hqu4r6k1jqio","title":"Without IDX"},{"location":"tools/hosted-nodes/community-nodes/","text":"Community Nodes \u00b6 This page contains a list of free, hosted Ceramic nodes made available by the community for the purposes of easily developing applications using the JS HTTP Client or the CLI. Warning: These nodes will be periodically wiped and streams may disappear, so please don't rely on them for long-term persistence and availability of data . If you need longer-term persistence, consider hosting your own node . Also note that streams created on the Clay Testnet will not be accessible on Mainnet . Only use Mainnet nodes for production deployments. Gateways \u00b6 Gateways are nodes that provide read-only access to the Ceramic network. 3Box Labs provides free gateway nodes for use by the Ceramic community. Here is a list of their HTTP endpoints: Mainnet \u00b6 https://gateway.ceramic.network Clay testnet \u00b6 https://gateway-clay.ceramic.network Write/Read Nodes \u00b6 Nodes provide full read and write access to the Ceramic network. 3Box Labs provides free write/read nodes for Ceramic developers. These nodes will run the latest release candidate of the Ceramic protocol. Here is a list of their HTTP endpoints: Clay testnet \u00b6 https://ceramic-clay.3boxlabs.com","title":"Community nodes"},{"location":"tools/hosted-nodes/community-nodes/#community-nodes","text":"This page contains a list of free, hosted Ceramic nodes made available by the community for the purposes of easily developing applications using the JS HTTP Client or the CLI. Warning: These nodes will be periodically wiped and streams may disappear, so please don't rely on them for long-term persistence and availability of data . If you need longer-term persistence, consider hosting your own node . Also note that streams created on the Clay Testnet will not be accessible on Mainnet . Only use Mainnet nodes for production deployments.","title":"Community Nodes"},{"location":"tools/hosted-nodes/community-nodes/#gateways","text":"Gateways are nodes that provide read-only access to the Ceramic network. 3Box Labs provides free gateway nodes for use by the Ceramic community. Here is a list of their HTTP endpoints:","title":"Gateways"},{"location":"tools/hosted-nodes/community-nodes/#mainnet","text":"https://gateway.ceramic.network","title":"Mainnet"},{"location":"tools/hosted-nodes/community-nodes/#clay-testnet","text":"https://gateway-clay.ceramic.network","title":"Clay testnet"},{"location":"tools/hosted-nodes/community-nodes/#writeread-nodes","text":"Nodes provide full read and write access to the Ceramic network. 3Box Labs provides free write/read nodes for Ceramic developers. These nodes will run the latest release candidate of the Ceramic protocol. Here is a list of their HTTP endpoints:","title":"Write/Read Nodes"},{"location":"tools/hosted-nodes/community-nodes/#clay-testnet_1","text":"https://ceramic-clay.3boxlabs.com","title":"Clay testnet"},{"location":"tools/hosted-nodes/node-providers/","text":"Node Providers \u00b6 This page contains a list of third-party node hosting services that offer commercial-grade Ceramic nodes for developers. If you're interested in a list of free nodes, see Community Nodes . Providers \u00b6 To be the first to offer commercial-grade nodes for Ceramic developers and applications, please get in touch on Discord .","title":"Node Providers"},{"location":"tools/hosted-nodes/node-providers/#node-providers","text":"This page contains a list of third-party node hosting services that offer commercial-grade Ceramic nodes for developers. If you're interested in a list of free nodes, see Community Nodes .","title":"Node Providers"},{"location":"tools/hosted-nodes/node-providers/#providers","text":"To be the first to offer commercial-grade nodes for Ceramic developers and applications, please get in touch on Discord .","title":"Providers"},{"location":"tools/identity/identitylink/","text":"IdentityLink \u00b6 IdentityLink is a service that issues verifiable claims which prove that a DID owns one or more Web2 social accounts. Once issued these claims can be stored anywhere, however it is recommended to store them in a user's IDX under the Also Known As definition. Compatibility \u00b6 DID Methods \u00b6 IdentityLink works with all DID methods. Web2 Platforms \u00b6 IdentityLink currently supports: Twitter Github Discord Discourse Telegram Instagram (coming soon) How it works \u00b6 Public DNS \u00b6 For platforms that allow users to post content to public DNS endpoints (i.e. Twitter, Github): Private servers \u00b6 For platforms that restrict messages to private servers (i.e. Telegram, Discord): Usage \u00b6 Use the IdentityLink service hosted by 3Box Labs \u00b6 Add more about how to add it to your project. Run your own IdentityLink service \u00b6 Point to the relevant instructions on how to run it yourself. Learn more \u00b6 Visit the IdentityLink repository on Github for full documentation.","title":"IdentityLink"},{"location":"tools/identity/identitylink/#identitylink","text":"IdentityLink is a service that issues verifiable claims which prove that a DID owns one or more Web2 social accounts. Once issued these claims can be stored anywhere, however it is recommended to store them in a user's IDX under the Also Known As definition.","title":"IdentityLink"},{"location":"tools/identity/identitylink/#compatibility","text":"","title":"Compatibility"},{"location":"tools/identity/identitylink/#did-methods","text":"IdentityLink works with all DID methods.","title":"DID Methods"},{"location":"tools/identity/identitylink/#web2-platforms","text":"IdentityLink currently supports: Twitter Github Discord Discourse Telegram Instagram (coming soon)","title":"Web2 Platforms"},{"location":"tools/identity/identitylink/#how-it-works","text":"","title":"How it works"},{"location":"tools/identity/identitylink/#public-dns","text":"For platforms that allow users to post content to public DNS endpoints (i.e. Twitter, Github):","title":"Public DNS"},{"location":"tools/identity/identitylink/#private-servers","text":"For platforms that restrict messages to private servers (i.e. Telegram, Discord):","title":"Private servers"},{"location":"tools/identity/identitylink/#usage","text":"","title":"Usage"},{"location":"tools/identity/identitylink/#use-the-identitylink-service-hosted-by-3box-labs","text":"Add more about how to add it to your project.","title":"Use the IdentityLink service hosted by 3Box Labs"},{"location":"tools/identity/identitylink/#run-your-own-identitylink-service","text":"Point to the relevant instructions on how to run it yourself.","title":"Run your own IdentityLink service"},{"location":"tools/identity/identitylink/#learn-more","text":"Visit the IdentityLink repository on Github for full documentation.","title":"Learn more"},{"location":"tools/identity/idx/","text":"IDX \u00b6 IDX is a decentralized identity protocol and JavaScript SDK that provides APIs which make it easy for developers to build applications with user-controlled streams for storing data, as well as to discover and make use of user data created on third-party applications. Building with IDX allows users to control their identities and data in a manner independent from any single application, while allowing developers to build data-rich applications without the liability of custodying user data on a centralized server or the poor user experience of forcing users to recreate the same data on every application. This page mentions that IDX is intended for storing \"user\" data as that is its primary use case. However IDX can be used for storing data for other types of subjects represented by DIDs such as businesses, organizations, applications, assets (NFTs), or devices (IoT). Features \u00b6 DID-compatibility : IDX does not provide DIDs , but relies on them for decentralized, platform-agnostic identifiers. IDX can work with any DID method that is supported in Ceramic. Various DID methods, such as 3ID , support linking to and authenticating with many different blockchain accounts (see 3ID Keychain (CIP-20) ). This allows DIDs to serve as a universal, cross-chain and platform-agnostic identifier for users. Stream-based storage : Store data for your users or your application in user-controlled streams on Ceramic. Data in streams can be stored in cleartext or encrypted. IDX-created streams enjoy all the benefits of mutability, persistence, replication, and availability provided by the Ceramic network. Identity hubs : Whenever a user stores data in a new stream via IDX, its streamID is automatically registered in their index, which is a separate stream that serves as a single catalog of references to all their data. The index enables all data associations for the user to exist in one place, which in turn enables any application to discover all data about the user by simply querying their index. Public, semantic data descriptions : All data stored via IDX is semantically described and organized in the user's index, allowing multiple applications to make use of the same data based on schemas and metadata instead of which application the user was using when they first created the data. Cross-application data portability : The combination of DIDs, streams, hubs, and semantic data descriptions allows user data to be stored in an application-agnostic manner and can be used across different applications or interfaces. No application maintains \"special permissions\" since users are in full control. Standard interfaces : IDX provides standardized read/write APIs for interacting with all data so applications aren't ever forced to integrate one-off APIs. Built on open standards : IDX builds on open standards for decentralized identity shepherded by the Ceramic community via CIPs, and other related identity communities such as W3C and the Decentralized Identity Foundation (DIF) . Protocol design \u00b6 Dive into the design and architecture of the IDX protocol, which is implemented by the IDX SDK. Index \u00b6 The index is a stream controlled by the user's DID which stores entries consisting of definition (represented by a streamID) to record (represented by a streamID) mappings. Every DID has only one global index and its entries represent the entire catalog of data that belongs to the user. An index is similar to a row in a user table, and enables the decentralized association and discovery of streams that belong to a user. Example: { \"kyz123...456\" : \"ceramic://kyz789...012\" , \"kyz345...678\" : \"ceramic://kyz901...234\" , \"kyz567...890\" : \"ceramic://kyz123...456\" , \"kyz789...012\" : \"ceramic://kyz345...678\" } Definitions \u00b6 Definitions are streams created by application developers that store metadata which describes the stream used for data storage. Definitions allow records to be semantically described and queried using their metadata or schema and are similar to a column in a user table. The streamID of the definition is a key in the index . Example: { name : 'Basic Profile' , description : 'A simple basic profile.' , schema : 'ceramic://kyz123...456' } Schemas \u00b6 Schemas are streams created by application developers that store a JSON schema. They specify the data schema of a record . Schemas are identified by the streamID of the stream that stores the schema, which is included in the definition as seen above. Records \u00b6 Records are streams that store information for a DID. They can directly store content, or they can store foreign key references to external datastores outside of Ceramic. A record is similar to a cell in a user table. The streamID of the record is a value in the index . Example: { name : 'Alan Turing' , description : 'I make computers beep good.' , emoji : '\ud83d\udcbb' } How it works \u00b6 Storing data with IDX \u00b6 Application developer creates stream that contains a JSON schema. Application developer creates a stream that contains a definition and includes the StreamID of the stream containing the schema. User creates a record (a stream) that conforms to the definition as they interact with an application. IDX automatically adds the definition streamID and the record streamID as an entry in the user's index. Reading data from IDX \u00b6 Application queries a user's index by passing the user's DID and the streamID of a definition. Before performing this action, an application can query the user's entire index to see which definitions they have. Application gets back the record that corresponds to the definition. Sample Use Cases \u00b6 Authentication secrets : 3ID Connect uses IDX to create a DID-controlled stream which stores encrypted authentication secrets that allows a 3ID DID to be authenticated with various blockchain wallets. To achieve this, the 3ID Connect team has created the 3ID Keychain definition (CIP-20) . Profile information : DNS.xyz uses IDX to create a DID-controlled stream which stores basic profile information for the DID. To achieve this, the DNS.xyz team uses the Basic Profile definition (CIP-19) . Web2 social account links : Self.ID uses IDX to create a DID-controlled stream which stores a list of Web2 accounts controlled by the same user that owns the DID, along with verifiable claims which prove this ownership. To achieve this, the Self.ID team has created the Also Known As (AKA) definition (CIP-23) . Web3 Crypto account links : 3ID Connect uses IDX to create a DID-controlled stream which stores a list of streamIDs for CAIP10Links that publicly prove the owner of this DID also owns various accounts on Web3/blockchain platforms. To achieve this, the 3ID Connect team has created the Crypto Accounts definition (CIP-21) . Implementations \u00b6 IDX is available as a JavaScript client library. Usage \u00b6 Visit the IDX documentation to install and use IDX in your project. Learn more \u00b6 Website Documentation Full Identity Index (IDX) protocol specification (CIP-11) Discord community","title":"IDX"},{"location":"tools/identity/idx/#idx","text":"IDX is a decentralized identity protocol and JavaScript SDK that provides APIs which make it easy for developers to build applications with user-controlled streams for storing data, as well as to discover and make use of user data created on third-party applications. Building with IDX allows users to control their identities and data in a manner independent from any single application, while allowing developers to build data-rich applications without the liability of custodying user data on a centralized server or the poor user experience of forcing users to recreate the same data on every application. This page mentions that IDX is intended for storing \"user\" data as that is its primary use case. However IDX can be used for storing data for other types of subjects represented by DIDs such as businesses, organizations, applications, assets (NFTs), or devices (IoT).","title":"IDX"},{"location":"tools/identity/idx/#features","text":"DID-compatibility : IDX does not provide DIDs , but relies on them for decentralized, platform-agnostic identifiers. IDX can work with any DID method that is supported in Ceramic. Various DID methods, such as 3ID , support linking to and authenticating with many different blockchain accounts (see 3ID Keychain (CIP-20) ). This allows DIDs to serve as a universal, cross-chain and platform-agnostic identifier for users. Stream-based storage : Store data for your users or your application in user-controlled streams on Ceramic. Data in streams can be stored in cleartext or encrypted. IDX-created streams enjoy all the benefits of mutability, persistence, replication, and availability provided by the Ceramic network. Identity hubs : Whenever a user stores data in a new stream via IDX, its streamID is automatically registered in their index, which is a separate stream that serves as a single catalog of references to all their data. The index enables all data associations for the user to exist in one place, which in turn enables any application to discover all data about the user by simply querying their index. Public, semantic data descriptions : All data stored via IDX is semantically described and organized in the user's index, allowing multiple applications to make use of the same data based on schemas and metadata instead of which application the user was using when they first created the data. Cross-application data portability : The combination of DIDs, streams, hubs, and semantic data descriptions allows user data to be stored in an application-agnostic manner and can be used across different applications or interfaces. No application maintains \"special permissions\" since users are in full control. Standard interfaces : IDX provides standardized read/write APIs for interacting with all data so applications aren't ever forced to integrate one-off APIs. Built on open standards : IDX builds on open standards for decentralized identity shepherded by the Ceramic community via CIPs, and other related identity communities such as W3C and the Decentralized Identity Foundation (DIF) .","title":"Features"},{"location":"tools/identity/idx/#protocol-design","text":"Dive into the design and architecture of the IDX protocol, which is implemented by the IDX SDK.","title":"Protocol design"},{"location":"tools/identity/idx/#index","text":"The index is a stream controlled by the user's DID which stores entries consisting of definition (represented by a streamID) to record (represented by a streamID) mappings. Every DID has only one global index and its entries represent the entire catalog of data that belongs to the user. An index is similar to a row in a user table, and enables the decentralized association and discovery of streams that belong to a user. Example: { \"kyz123...456\" : \"ceramic://kyz789...012\" , \"kyz345...678\" : \"ceramic://kyz901...234\" , \"kyz567...890\" : \"ceramic://kyz123...456\" , \"kyz789...012\" : \"ceramic://kyz345...678\" }","title":"Index"},{"location":"tools/identity/idx/#definitions","text":"Definitions are streams created by application developers that store metadata which describes the stream used for data storage. Definitions allow records to be semantically described and queried using their metadata or schema and are similar to a column in a user table. The streamID of the definition is a key in the index . Example: { name : 'Basic Profile' , description : 'A simple basic profile.' , schema : 'ceramic://kyz123...456' }","title":"Definitions"},{"location":"tools/identity/idx/#schemas","text":"Schemas are streams created by application developers that store a JSON schema. They specify the data schema of a record . Schemas are identified by the streamID of the stream that stores the schema, which is included in the definition as seen above.","title":"Schemas"},{"location":"tools/identity/idx/#records","text":"Records are streams that store information for a DID. They can directly store content, or they can store foreign key references to external datastores outside of Ceramic. A record is similar to a cell in a user table. The streamID of the record is a value in the index . Example: { name : 'Alan Turing' , description : 'I make computers beep good.' , emoji : '\ud83d\udcbb' }","title":"Records"},{"location":"tools/identity/idx/#how-it-works","text":"","title":"How it works"},{"location":"tools/identity/idx/#storing-data-with-idx","text":"Application developer creates stream that contains a JSON schema. Application developer creates a stream that contains a definition and includes the StreamID of the stream containing the schema. User creates a record (a stream) that conforms to the definition as they interact with an application. IDX automatically adds the definition streamID and the record streamID as an entry in the user's index.","title":"Storing data with IDX"},{"location":"tools/identity/idx/#reading-data-from-idx","text":"Application queries a user's index by passing the user's DID and the streamID of a definition. Before performing this action, an application can query the user's entire index to see which definitions they have. Application gets back the record that corresponds to the definition.","title":"Reading data from IDX"},{"location":"tools/identity/idx/#sample-use-cases","text":"Authentication secrets : 3ID Connect uses IDX to create a DID-controlled stream which stores encrypted authentication secrets that allows a 3ID DID to be authenticated with various blockchain wallets. To achieve this, the 3ID Connect team has created the 3ID Keychain definition (CIP-20) . Profile information : DNS.xyz uses IDX to create a DID-controlled stream which stores basic profile information for the DID. To achieve this, the DNS.xyz team uses the Basic Profile definition (CIP-19) . Web2 social account links : Self.ID uses IDX to create a DID-controlled stream which stores a list of Web2 accounts controlled by the same user that owns the DID, along with verifiable claims which prove this ownership. To achieve this, the Self.ID team has created the Also Known As (AKA) definition (CIP-23) . Web3 Crypto account links : 3ID Connect uses IDX to create a DID-controlled stream which stores a list of streamIDs for CAIP10Links that publicly prove the owner of this DID also owns various accounts on Web3/blockchain platforms. To achieve this, the 3ID Connect team has created the Crypto Accounts definition (CIP-21) .","title":"Sample Use Cases"},{"location":"tools/identity/idx/#implementations","text":"IDX is available as a JavaScript client library.","title":"Implementations"},{"location":"tools/identity/idx/#usage","text":"Visit the IDX documentation to install and use IDX in your project.","title":"Usage"},{"location":"tools/identity/idx/#learn-more","text":"Website Documentation Full Identity Index (IDX) protocol specification (CIP-11) Discord community","title":"Learn more"},{"location":"tools/identity/self-id/","text":"Self.ID (coming soon) \u00b6 Self.ID is a web application that allows users to manage their basic, profile-related IDX records. Usage \u00b6 Design \u00b6 Self.ID integrates with the following standards, tools and services. Authentication \u00b6 3ID Connect: Uses 3ID DID method and allows users to authenticate with their existing blockchain wallets. Identity \u00b6 IDX: IdentityLink: Definitions \u00b6 Basic Profile: 3ID Keychain: Also Known As:","title":"Self.id"},{"location":"tools/identity/self-id/#selfid-coming-soon","text":"Self.ID is a web application that allows users to manage their basic, profile-related IDX records.","title":"Self.ID (coming soon)"},{"location":"tools/identity/self-id/#usage","text":"","title":"Usage"},{"location":"tools/identity/self-id/#design","text":"Self.ID integrates with the following standards, tools and services.","title":"Design"},{"location":"tools/identity/self-id/#authentication","text":"3ID Connect: Uses 3ID DID method and allows users to authenticate with their existing blockchain wallets.","title":"Authentication"},{"location":"tools/identity/self-id/#identity","text":"IDX: IdentityLink:","title":"Identity"},{"location":"tools/identity/self-id/#definitions","text":"Basic Profile: 3ID Keychain: Also Known As:","title":"Definitions"}]}